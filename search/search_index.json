{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre","text":"Intelig\u00eancia Artificial - Engenharia de Software - UnB  <p>Este reposit\u00f3rio serve como portf\u00f3lio e material de apoio para a disciplina de Intelig\u00eancia Artificial do curso de Engenharia de Software na Universidade de Bras\u00edlia (UnB). Aqui voc\u00ea encontrar\u00e1 informa\u00e7\u00f5es sobre a ementa, os conte\u00fados abordados e os objetivos da mat\u00e9ria, al\u00e9m de projetos pr\u00e1ticos desenvolvidos ao longo do curso.</p>  1. Sobre a Aluna  <p>Aluna: Sabrina Caldas Berno Matr\u00edcula: 211029586 Estudante de Engenharia de Software na Universidade de Bras\u00edlia, com foco em desenvolvimento de sistemas inteligentes e aplica\u00e7\u00e3o de t\u00e9cnicas de IA. </p> <p>Links para contato: - LinkedIn - GitHub</p>  2. Descri\u00e7\u00e3o da Disciplina  <p>A disciplina de Intelig\u00eancia Artificial introduz conceitos fundamentais para a representa\u00e7\u00e3o do conhecimento, resolu\u00e7\u00e3o de problemas e m\u00e9todos de aprendizagem, com foco em preparar os alunos para o desenvolvimento de sistemas inteligentes. Ao final do curso, os alunos dever\u00e3o ser capazes de:</p> <ul> <li>Desenvolver sistemas inteligentes em diversas aplica\u00e7\u00f5es.</li> <li>Compreender o papel essencial da representa\u00e7\u00e3o do conhecimento.</li> <li>Resolver problemas de aprendizagem em engenharia de sistemas inteligentes.</li> </ul>  2.1 Objetivos  <p>O objetivo da disciplina \u00e9 fornecer aos alunos metodologias fundamentais para o desenvolvimento de sistemas inteligentes, abordando conceitos como agentes inteligentes, resolu\u00e7\u00e3o de problemas, representa\u00e7\u00e3o do conhecimento, incerteza e aprendizado de m\u00e1quina. Al\u00e9m disso, a disciplina visa apresentar a intelig\u00eancia artificial de forma estruturada, priorizando conceitos essenciais sobre \u00e1reas espec\u00edficas do tema, e introduzir tanto t\u00e9cnicas cl\u00e1ssicas (como algoritmos gen\u00e9ticos) quanto modernas (como deep learning), oferecendo uma vis\u00e3o ampla do campo da IA.</p>  3. Conte\u00fados  <p>Os principais t\u00f3picos abordados na disciplina incluem:</p> <ol> <li>Introdu\u00e7\u00e3o \u00e0 intelig\u00eancia artificial: Hist\u00f3rico, estado da arte, benef\u00edcios e riscos; agentes inteligentes, ambientes e racionalidade.</li> <li>Resolu\u00e7\u00e3o de problemas por busca: T\u00e9cnicas para encontrar solu\u00e7\u00f5es \u00f3timas em espa\u00e7os de busca.</li> <li>Problemas de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es: Modelagem de problemas onde as solu\u00e7\u00f5es precisam atender a um conjunto espec\u00edfico de restri\u00e7\u00f5es.</li> <li>Agentes l\u00f3gicos: Uso da l\u00f3gica para tomada de decis\u00f5es e resolu\u00e7\u00e3o de problemas.</li> <li>Quantifica\u00e7\u00e3o de incertezas e redes Bayesianas: Racioc\u00ednio probabil\u00edstico e filtros de Kalman.</li> <li>Aprendizado de m\u00e1quina: M\u00e9todos e t\u00e9cnicas para que sistemas aprendam e se adaptem a partir de dados.</li> </ol> <p>Este portf\u00f3lio ser\u00e1 atualizado constantemente, documentando o progresso nas atividades e projetos ao longo do semestre.</p>"},{"location":"modulo1/AI-Index-2024/","title":"AI Index Report 2024","text":"AI Index Report <p> O AI Index \u00e9 um relat\u00f3rio anual que fornece uma vis\u00e3o abrangente sobre o progresso da intelig\u00eancia artificial (IA) com base em diferentes \u00e1reas, como pesquisa, mercado, educa\u00e7\u00e3o e desempenho tecnol\u00f3gico. Seu objetivo \u00e9 fornecer dados imparciais, rigorosamente verificados e com fontes amplamente diversificadas, para que policymakers, pesquisadores, executivos, jornalistas e o p\u00fablico geral possam desenvolver uma compreens\u00e3o mais profunda e detalhada do campo complexo da IA. Este relat\u00f3rio \u00e9 reconhecido globalmente como uma das fontes mais cred\u00edveis e autoritativas para dados e insights sobre a intelig\u00eancia artificial (Stanford, 2024). </p> <p> Por\u00e9m, esses avan\u00e7os tamb\u00e9m trazem desafios, particularmente os desafios \u00e9ticos envolvidos no uso da IA. A privacidade de dados, o vi\u00e9s algor\u00edtmico e a transpar\u00eancia dos sistemas de IA s\u00e3o quest\u00f5es centrais discutidas no relat\u00f3rio e no t\u00f3pico limita\u00e7\u00f5es, riscos e \u00e9tica.(Stanford, 2024). </p> <p> A diversidade de g\u00eanero  na IA continua sendo um desafio, com as mulheres representando apenas 20% dos profissionais, enquanto os homens s\u00e3o 80% (AI Index relat\u00f3rios 2018-2019). No entanto, h\u00e1 iniciativas para aumentar a inclus\u00e3o feminina, como programas de mentoria e bolsas de estudo. A participa\u00e7\u00e3o feminina em confer\u00eancias como o NeurIPS cresceu mais de 800% desde 2012, mostrando uma evolu\u00e7\u00e3o positiva, mas o ambiente ainda \u00e9 predominantemente masculino, o que dificulta uma inclus\u00e3o plena (Stanford, 2024). </p> <p></p> <p> Um os t\u00f3picos abordados no Index AI 2024 foi The data is in: AI makes workers more productive and leads to higher quality work , podendo ser encontrado no cap\u00edtulo 4.  </p> <p> A utiliza\u00e7\u00e3o de ferramentas de IA por desenvolvedores de software est\u00e1 crescendo rapidamente, com 56% dos entrevistados no levantamento anual do Stack Overflow de 2023 reportando o uso do GitHub Copilot. Quanto \u00e0 integra\u00e7\u00e3o de IA nos fluxos de trabalho dos desenvolvedores, 82,6% utilizam IA para escrita de c\u00f3digo, 48,9% para depura\u00e7\u00e3o e 34,4% para documenta\u00e7\u00e3o. A ado\u00e7\u00e3o de IA para testes de c\u00f3digo, embora em 23,9% dos casos, tem 55,2% de interesse futuro. </p> <p> De acordo com os desenvolvedores, a principal vantagem da IA \u00e9 o aumento da produtividade (32,8%), seguida por aprendizado acelerado (25,2%) e efici\u00eancia aprimorada (25,0%). Uma grande maioria dos desenvolvedores tem uma vis\u00e3o positiva das ferramentas de IA, com 27,7% tendo uma opini\u00e3o muito favor\u00e1vel e 48,4% favor\u00e1vel. Por exemplo, o uso do Copilot reduziu o tempo de execu\u00e7\u00e3o de tarefas de 26% a 73% em compara\u00e7\u00e3o com desenvolvedores sem IA. A produtividade aumentou em 12,2%, a velocidade em 25,1% e a qualidade em 40% para consultores que utilizaram o GPT-4, comparado a um grupo de controle sem acesso \u00e0 IA. </p> <p> Al\u00e9m disso, a IA pode reduzir a disparidade de desempenho entre trabalhadores de diferentes habilidades, com trabalhadores menos qualificados mostrando um aumento de 43% no desempenho ap\u00f3s o uso de IA, enquanto trabalhadores mais qualificados apresentaram um aumento de 16,5%. </p> <p></p> Conclus\u00e3o <p> Com base nas informa\u00e7\u00f5es apresentadas, fica claro que a IA tem se consolidado como uma ferramenta muito boa para aumentar a produtividade e a qualidade do trabalho, especialmente no contexto dos desenvolvedores de software. O uso de ferramentas como o GitHub Copilot tem mostrado uma redu\u00e7\u00e3o significativa no tempo de execu\u00e7\u00e3o de tarefas e um aumento not\u00e1vel na efici\u00eancia. Al\u00e9m disso, a IA est\u00e1 cada vez mais integrada aos fluxos de trabalho dos desenvolvedores, n\u00e3o s\u00f3 para a escrita de c\u00f3digo, mas tamb\u00e9m para depura\u00e7\u00e3o, documenta\u00e7\u00e3o e, em breve, at\u00e9 mesmo para testes de c\u00f3digo.  </p> <p> No entanto, acredito que \u00e9 importante refletirmos sobre os impactos a longo prazo dessa crescente depend\u00eancia da IA, especialmente para desenvolvedores menos qualificados. Embora a IA seja uma excelente ferramenta para acelerar o processo de aprendizado e desenvolvimento, o uso excessivo pode reduzir a capacidade desses profissionais em buscar solu\u00e7\u00f5es por conta pr\u00f3pria e em desenvolver um pensamento cr\u00edtico. A IA pode fornecer respostas r\u00e1pidas, mas ser\u00e1 que ela est\u00e1 ajudando essas pessoas a se tornarem profissionais mais completos no futuro? \u00c9 poss\u00edvel que, ao se apoiar tanto nas ferramentas de IA, elas n\u00e3o desenvolvam a mesma autonomia e as habilidades essenciais que os profissionais mais experientes possuem atualmente?  </p> <p> No curto prazo, ela pode proporcionar uma acelera\u00e7\u00e3o no aprendizado e uma melhoria nas entregas, mas no longo prazo, o verdadeiro desenvolvimento de um profissional n\u00e3o deve depender apenas da tecnologia. Os profissionais mais qualificados hoje provavelmente alcan\u00e7aram um n\u00edvel de experi\u00eancia que vem com a pr\u00e1tica constante, a resolu\u00e7\u00e3o de problemas e o desenvolvimento de habilidades cr\u00edticas. Se os desenvolvedores mais novos, que utilizam IA, n\u00e3o praticarem essas habilidades, existe o risco de que, no futuro, sua capacidade de resolu\u00e7\u00e3o de problemas complexos e de adapta\u00e7\u00e3o a novos desafios seja limitada. </p> <p> Portanto, \u00e9 importante encontrar um equil\u00edbrio entre aproveitar os benef\u00edcios da IA para aumentar a produtividade e garantir que as novas gera\u00e7\u00f5es de desenvolvedores sigam aprimorando suas habilidades de resolu\u00e7\u00e3o de problemas e pensamento cr\u00edtico.  </p>"},{"location":"modulo1/IA/","title":"Intelig\u00eancia Artificial","text":"Intelig\u00eancia Artificial <p> Com a chegada dos computadores modernos ap\u00f3s a Segunda Guerra Mundial, abriu-se a possibilidade de desenvolver programas capazes de executar tarefas acad\u00eamicas complexas. Esse avan\u00e7o, aliado a novas descobertas na \u00e1rea da neuroci\u00eancia, levou cientistas a considerar a cria\u00e7\u00e3o de um \"c\u00e9rebro eletr\u00f4nico\", ideia que eventualmente se transformaria no conceito de intelig\u00eancia artificial (Jeffery, 2022). A IA pode ser entendida de diferentes maneiras, incluindo agir como humanos, pensar como humanos, pensar racionalmente e agir racionalmente. Essas abordagens variam desde a imita\u00e7\u00e3o do comportamento humano no Teste de Turing at\u00e9 a constru\u00e7\u00e3o de agentes aut\u00f4nomos que buscam os melhores resultados esperados (Soares, 2024). N\u00e3o existe, ainda, uma defini\u00e7\u00e3o  \u00fanica e amplamente aceita do que seria Intelig\u00eancia Artificial (Sheikh, 2023). Pode-se dizer que  IA significa a imita\u00e7\u00e3o por computadores da intelig\u00eancia inerente aos humanos (Sheikh, 2023), ou seja, elas n\u00e3o s\u00e3o apenas programadas para executar tarefas, mas sim para simular habilidades humanas, como o pensamento e o racioc\u00ednio. Essa defini\u00e7\u00e3o, no entanto, \u00e9 ampla e possui limita\u00e7\u00f5es, j\u00e1 que explica somente o termo \u201cintelig\u00eancia artificial\u201d em outras palavras. </p> <p> As origens da IA tamb\u00e9m podem ser encontradas em mitos e hist\u00f3rias de fic\u00e7\u00e3o cient\u00edfica. Desde o gigante de bronze Talos, na mitologia grega, at\u00e9 o rob\u00f4 Maria no filme \"Metropolis\" (1927), a ideia de criar m\u00e1quinas que simulam caracter\u00edsticas humanas tem fascinado a humanidade. Obras como \"Frankenstein\" (1818), de Mary Shelley, exploraram a cria\u00e7\u00e3o artificial de vida, enquanto o ensaio \"Darwin entre as M\u00e1quinas\" (1863), de Samuel Butler, especulou que as m\u00e1quinas poderiam evoluir e superar os humanos (Soares, 2024)</p> <p> Em 1997, Garry Kasparov, o campe\u00e3o mundial de xadrez, jogou este jogo contra o Deep Blue, um computador desenvolvido pela empresa IBM, e foi derrotado, marcando, naquele ano, o avan\u00e7o da intelig\u00eancia artificial e a supera\u00e7\u00e3o da \u201c\u00faltima resist\u00eancia do c\u00e9rebro\u201d (Sheikh, 2023). Na \u00e9poca, acreditava-se que o xadrez representava o \u00e1pice da intelig\u00eancia humana, e a vit\u00f3ria do Deep Blue gerou a expectativa de que os computadores poderiam superar os humanos em atividades consideradas mais simples do que o xadrez (Sheikh, 2023). No entanto, o xadrez  \u00e9 um problema matem\u00e1tico com regras muito claras e um conjunto finito de alternativas, o que n\u00e3o o torna muito diferente de uma calculadora de bolso, que tamb\u00e9m pode fazer coisas muito dif\u00edceis at\u00e9 para pessoas muito inteligente. Mas isso n\u00e3o torna a calculadora uma forma artificial de intelig\u00eancia humana. As dificuldades em definir IA n\u00e3o s\u00e3o, portanto, o resultado de alguma defici\u00eancia ou descuido, mas surgem do fato de que fomos incapazes de determinar precisamente qual intelig\u00eancia desejar\u00edamos replicar artificialmente. Dessa forma, definimos a Intelig\u00eancia Artificial como sistemas que exibem comportamento inteligente ao analisar seu ambiente e tomar a\u00e7\u00f5es \u2013 com algum grau de autonomia \u2013 para atingir objetivos espec\u00edficos. (Sheikh, 2023)  <p> Os avan\u00e7os da IA ao longo do tempo foram marcados por per\u00edodos de progresso e estagna\u00e7\u00e3o. Nos primeiros passos, entre 1943 e 1956, surgiram os modelos neurais de Warren McCulloch e Walter Pitts e o Teste de Turing, de Alan Turing e durante o per\u00edodo de otimismo, de 1952 a 1969, ocorreram inova\u00e7\u00f5es como o aprendizado por refor\u00e7o e o desenvolvimento dos perceptrons por Frank Rosenblatt (Soares, 2024). Por\u00e9m, as limita\u00e7\u00f5es da IA levaram ao primeiro \"inverno da IA\" (1966-1973). Em seguida, os sistemas especialistas, prinicipalmemte na \u00e1rea da sa\u00fade com os diagn\u00f3sticos m\u00e9dicos, marcaram um novo avan\u00e7o (1969-1986), mas tamb\u00e9m enfrentaram desafios de manuten\u00e7\u00e3o (Soares, 2024).</p> <p> A intelig\u00eancia artificial deu um grande avan\u00e7o na d\u00e9cada de 1980 com o retorno das redes neurais, em fun\u00e7\u00e3o de um algoritmo chamado retropropaga\u00e7\u00e3o. Esse algoritmo basicamente ensina as redes neurais a aprenderem com os pr\u00f3prios erros, ajustando as conex\u00f5es internas para melhorar os resultados. As redes baseadas nesse m\u00e9todo, conhecidas como modelos conexionistas, se mostraram super eficazes e flex\u00edveis. Esse per\u00edodo impulsionou a IA para a forma como ela \u00e9 usada hoje, ajudando a criar as bases para tecnologias como reconhecimento de voz, tradu\u00e7\u00e3o autom\u00e1tica e as ferramentas conversacionais, como o ChatGPT e o Gemini.</p> Aprendizado de M\u00e1quina <p> Aprendizado de M\u00e1quina, subconjunto da IA,  envolve a capacidade de computadores de interpretar grandes volumes de dados, construir modelos baseados nesses dados e, assim, gerar hip\u00f3teses ou previs\u00f5es sobre o mundo ao seu redor (Russel, 2016). Tradicionalmente, os computadores seguem rigorosamente as regras criadas pelos desenvolvedores, entretanto os avan\u00e7os da ind\u00fastria 4.0 os permitiu executar a\u00e7\u00f5es sem o passo a passo definido (Ris-Ala, 2023). Esses modelos atuam como uma \"hip\u00f3tese digital\" sobre o comportamento dos dados, permitindo que o sistema resolva problemas ou tome decis\u00f5es de forma automatizada (Russel, 2016). Nesse caso, a ML est\u00e1 sendo expandida para v\u00e1rios setores, como na medicina, a qual algoritmos podem ser treinados para reconhecer padr\u00f5es gen\u00e9ticos em embri\u00f5es e classificar o melhor embri\u00e3o para implanta\u00e7\u00e3o e, a partir disso, prever essas quest\u00f5es em novos embri\u00f5es. Ele pode ser de tr\u00eas tipos: supervisionada, n\u00e3o supervisionada e por refor\u00e7o. </p> <p> O aprendizado supervisionado \u00e9 uma das t\u00e9cnicas mais comuns e envolve o treinamento de algoritmos com um conjunto de dados rotulados. Isso significa que o algoritmo recebe um conjunto de dados de entrada e sa\u00edda conhecidos, permitindo que ele aprenda a correlacionar as vari\u00e1veis de entrada (inputs) com os resultados esperados (outputs) (Russell, 2016). O processo consiste em alimentar o algoritmo com esses dados rotulados, ajustar os par\u00e2metros do modelo com base nas diferen\u00e7as entre as previs\u00f5es e os resultados reais, e repetir o ciclo at\u00e9 que o desempenho seja satisfat\u00f3rio e preciso (Trask, 2019). </p> <p> Uma das t\u00e9cnicas de aprendizado supervisionado \u00e9 a classifica\u00e7\u00e3o, que busca atribuir r\u00f3tulos ou classes pr\u00e9-definidas aos dados (Google, 2024). Isso \u00e9 feito com um modelo treinado com um conjunto de dados que possuem as entradas e as respectivas classes conhecidas, assim o algoritmo aprende a identificar padr\u00f5es ou caracter\u00edsticas que diferenciam essas classes (Google, 2024). No contexto da medicina reprodutiva, treinado com um conjunto de dados rotulados, como euploides e aneuploides, o aprendizado supervisionado com algoritmo de classifica\u00e7\u00e3o aprende a reconhecer caracter\u00edsticas comum desses dados e, em seguida, consegue prever a probabilidade de um novo embri\u00e3o estar em alguma dessas categorias.</p> <p> De maneira geral, um algoritmo de aprendizado supervisionado separa o banco de dados, seja de forma aleat\u00f3ria ou pr\u00e9-definida, em tr\u00eas subconjuntos: treinamento, valida\u00e7\u00e3o e testes (Google, 2024). Na primeira etapa, chamada de fase de treinamento, o algoritmo \u00e9 ajustado para identificar padr\u00f5es nos dados de entrada e associ\u00e1-los \u00e0s classes desejadas (Google, 2024). Em seguida, na fase de valida\u00e7\u00e3o, utiliza-se outro subconjunto de dados, que n\u00e3o foi usado no treinamento, para avaliar o desempenho do modelo, comparando suas previs\u00f5es com as respostas corretas (Google, 2024). Se os resultados n\u00e3o forem satisfat\u00f3rios, os hiperpar\u00e2metros \u2013 par\u00e2metros que orientam o processo de treinamento \u2013 devem ser ajustados, e o banco de dados \u00e9 reorganizado e dividido novamente, repetindo-se as duas etapas iniciais (Google, 2024). Ap\u00f3s obter um resultado satisfat\u00f3rio, aplica-se o conjunto de testes para mensurar m\u00e9tricas de acur\u00e1cia, recall, precis\u00e3o, entre outros, garantindo o desempenho esperado da IA (Google, 2024). </p> <p> No aprendizado n\u00e3o supervisionado, o algoritmo de Machine Learning analisa os dados, explora hip\u00f3teses de correla\u00e7\u00f5es e relacionamentos entre eles para identificar padr\u00f5es (Russel, 2016). Diferente do aprendizado supervisionado, aqui s\u00f3 as entradas s\u00e3o fornecidas, pois o objetivo \u00e9 descobrir a estrutura subjacente dos dados. O algoritmo tenta agrupar os dados com base em caracter\u00edsticas comuns, em um processo conhecido como clustering (Trask, 2019). Essa abordagem \u00e9 vantajosa, pois permite identificar padr\u00f5es desconhecidos nos dados. </p> <p> O aprendizado por refor\u00e7o possibilita que um sistema descubra o comportamento ideal atrav\u00e9s de intera\u00e7\u00f5es de tentativa e erro com o ambiente. O sistema explora diferentes estrat\u00e9gias e recebe feedback com base nos resultados das escolhas feitas (Ris-Ala, 2023). Esse m\u00e9todo imita o processo de aprendizado do c\u00e9rebro humano. Nesse tipo de aprendizado, n\u00e3o existe um conjunto de dados pr\u00e9-definido, pois a m\u00e1quina precisa interagir com o ambiente para coletar as informa\u00e7\u00f5es necess\u00e1rias (Ris-Ala, 2023). </p> <p> Assim, todas as abordagens de aprendizado compartilham a habilidade de adquirir conhecimento por meio do reconhecimento de padr\u00f5es. </p> <p></p> Redes Neurais <p> De acordo com Fleck et al. (2016, p. 50), uma rede neural \u00e9 um sistema projetado para modelar a maneira como o c\u00e9rebro realiza uma tarefa particular, sendo normalmente implementada utilizando-se componentes eletr\u00f4nicos ou \u00e9 simulada por propaga\u00e7\u00e3o em um computador digital. Para alcan\u00e7arem bom desempenho, as redes neurais empregam uma interliga\u00e7\u00e3o maci\u00e7a de c\u00e9lulas computacionais simples, denominadas de \u201cneur\u00f4nios\u201d ou unidades de processamento  </p> <p> matem\u00e1tico do neur\u00f4nio biol\u00f3gico desenvolvido por Warren McCulloch e Walter Pitts em 1943 (Gomes, 2010). Esse modelo, conhecido como neur\u00f4nio MCP (McCulloch-Pitts), consiste em um conjunto de entradas, que s\u00e3o multiplicadas por pesos espec\u00edficos. O resultado dessas multiplica\u00e7\u00f5es \u00e9 somado e, posteriormente, comparado a um valor de limiar para determinar a resposta do sistema (Fleck, 2016). </p> <p> As Redes Neurais Artificiais (RNAs) s\u00e3o frequentemente aplicadas na solu\u00e7\u00e3o de problemas complexos, especialmente quando o comportamento das vari\u00e1veis n\u00e3o \u00e9 completamente compreendido. Uma de suas principais caracter\u00edsticas \u00e9 a habilidade de aprender com base em exemplos, al\u00e9m de generalizar o conhecimento adquirido. Isso resulta na cria\u00e7\u00e3o de um modelo n\u00e3o linear, o que torna sua utiliza\u00e7\u00e3o na an\u00e1lise espacial altamente eficaz. </p>  Exemplo de uso  <p> O uso de Redes Neurais Artificiais (RNAs) na an\u00e1lise da ploidia de embri\u00f5es humanos se mostra promissor, principalmente devido \u00e0 sua capacidade de aprender e generalizar a partir de grandes volumes de dados complexos. No contexto da reprodu\u00e7\u00e3o assistida, a identifica\u00e7\u00e3o precisa de embri\u00f5es euploides e aneuploides \u00e9 essencial para o sucesso das t\u00e9cnicas de fertiliza\u00e7\u00e3o in vitro, pois a presen\u00e7a de aneuploidias pode resultar em falhas de implanta\u00e7\u00e3o e abortos espont\u00e2neos (Sousa, 2022). A escolha das RNAs para essa tarefa \u00e9 justificada pela sua habilidade em lidar com vari\u00e1veis de alta dimensionalidade e por sua capacidade de aprender padr\u00f5es n\u00e3o lineares, que s\u00e3o t\u00edpicos em dados biol\u00f3gicos e morfol\u00f3gicos (Sousa, 2022). </p> <p> Neste estudo, foi desenvolvida uma rede neural artificial adaptada para prever a ploidia dos embri\u00f5es. A escolha das RNAs como ferramenta para essa an\u00e1lise foi motivada por sua efic\u00e1cia em integrar diferentes tipos de dados e pela possibilidade de criar um modelo preditivo robusto (Sousa, 2022). </p> Big Data <p> Big Data refere-se a grandes volumes de dados que s\u00e3o gerados a partir de diversas fontes, como redes sociais, sensores, dispositivos m\u00f3veis e transa\u00e7\u00f5es online (Russell, 2016). Esses dados s\u00e3o caracterizados pelas chamadas \"3 Vs\": volume (quantidade imensa de informa\u00e7\u00f5es), velocidade (a rapidez com que s\u00e3o gerados e processados) e variedade (a diversidade de formatos, como texto, imagens e v\u00eddeos) (Camargo-Vega, 2015). O crescimento desses dados impulsionou o desenvolvimento de algoritmos de aprendizado para lidar com grandes volumes de informa\u00e7\u00e3o, muitas vezes n\u00e3o rotulada. Por exemplo, no caso da desambigua\u00e7\u00e3o de palavras, como \"planta\", que pode se referir a uma planta ou uma f\u00e1brica. Com volumes massivos de dados, algoritmos adequados conseguem alcan\u00e7ar alta precis\u00e3o (Russell, 2016). </p> Vantagens do Big Data segundo os autores de Conociendo Big Data: <ul> <li>Melhoria na tomada de decis\u00f5es: Com ferramentas anal\u00edticas, organiza\u00e7\u00f5es podem identificar padr\u00f5es e insights para decis\u00f5es mais embasadas.</li> <li>Automa\u00e7\u00e3o de processos: Big Data permite o uso de algoritmos que realizam tarefas em tempo real, como recomenda\u00e7\u00e3o de produtos.</li> <li>Otimiza\u00e7\u00e3o de estrat\u00e9gias de neg\u00f3cios: Dados detalhados ajudam a personalizar produtos e campanhas, aumentando a efici\u00eancia.</li> <li>Inova\u00e7\u00e3o tecnol\u00f3gica: \u00c1reas como IA e aprendizado de m\u00e1quina evolu\u00edram com o suporte de Big Data, aprimorando aplica\u00e7\u00f5es em sa\u00fade, transporte e seguran\u00e7a.</li> </ul> Desvantagens do Big Data segundo os autores de Conociendo Big Data: <ul> <li>Falta de profissionais qualificados: Muitas organiza\u00e7\u00f5es enfrentam dificuldades para encontrar especialistas em an\u00e1lise de dados.</li> <li>Complexidade t\u00e9cnica: Projetar arquiteturas para sistemas de Big Data pode ser desafiador e caro.</li> <li>Problemas de privacidade: Coletar e armazenar grandes volumes de dados pessoais pode gerar quest\u00f5es \u00e9ticas e legais.</li> <li>Custo elevado de implementa\u00e7\u00e3o: Ferramentas e infraestrutura para Big Data exigem investimentos substanciais.</li> <li>Velocidade e escalabilidade: Sistemas podem enfrentar limita\u00e7\u00f5es para processar consultas em tempo real ou para expandir de forma eficiente.</li> </ul> Aprendizado Profundo <p> Deep Learning, ou aprendizado profundo, \u00e9 uma sub\u00e1rea do aprendizado de m\u00e1quina que utiliza redes neurais compostas por v\u00e1rias camadas de processamento para aprender representa\u00e7\u00f5es de dados em diferentes n\u00edveis de abstra\u00e7\u00e3o (Russell, 2016). Essa abordagem permite lidar com dados complexos, como imagens, \u00e1udios e textos, sem a necessidade de interven\u00e7\u00e3o manual para extrair caracter\u00edsticas relevantes (Russell, 2016).  </p> As t\u00e9cnicas convencionais de aprendizado de m\u00e1quina apresentavam limita\u00e7\u00f5es ao processar dados naturais em sua forma bruta (LeCun, 2015). Deep Learning surgiu para superar essas limita\u00e7\u00f5es, substituindo a engenharia manual por redes neurais trein\u00e1veis que extraem automaticamente caracter\u00edsticas relevantes diretamente dos dados, utilizando camadas profundas de processamento (LeCun, 2015). <p> Tipos de Deep Learning segundo LeCun: <ul> <li>Aprendizado Supervisionado</li> <li>Convolutional Neural Networks (CNNs): Redes especializadas no processamento de dados em formatos de m\u00faltiplos arrays, como imagens</li> <li>Aprendizado N\u00e3o Supervisionado</li> <li>Recurrent Neural Networks (RNNs): Redes projetadas para processar sequ\u00eancias de dados, como texto ou s\u00e9ries temporais. Possuem conex\u00f5es recorrentes que permitem \"mem\u00f3ria\" de estados anteriores. Aplica\u00e7\u00f5es incluem tradu\u00e7\u00e3o autom\u00e1tica e an\u00e1lise de sentimentos. </li> <p> Apesar do sucesso do aprendizado profundo, sua aplica\u00e7\u00e3o enfrenta algumas limita\u00e7\u00f5es. A necessidade de hardware avan\u00e7ado representa um desafio, pois redes profundas demandam grande capacidade computacional para processar as opera\u00e7\u00f5es necess\u00e1rias durante o treinamento. Al\u00e9m disso, a depend\u00eancia de grandes volumes de dados \u00e9 uma restri\u00e7\u00e3o importante, j\u00e1 que o desempenho de modelos de deep learning est\u00e1 diretamente relacionado \u00e0 quantidade e \u00e0 qualidade dos dados dispon\u00edveis. Por \u00faltimo, o uso de algoritmos sofisticados tamb\u00e9m pode ser um obst\u00e1culo, pois exige estrat\u00e9gias avan\u00e7adas para lidar com problemas como overfitting e instabilidade no treinamento, tornando o desenvolvimento e a implementa\u00e7\u00e3o de redes profundas mais complexos e menos acess\u00edveis. (LeCun, 2015) </p>"},{"location":"modulo1/agentes/","title":"Agentes Inteligentes","text":"Agentes Inteligentes <p> Um agente de intelig\u00eancia artificial (IA) \u00e9 um programa de software que pode interagir com seu ambiente, coletar dados e usar os dados para realizar tarefas autodeterminadas para atingir metas predeterminadas (AWS, 2024). Esses agentes podem ser f\u00edsicos, como um rob\u00f4, ou virtuais, como um software. No caso de um agente de IA, ele utiliza os dados coletados para realizar tarefas de forma aut\u00f4noma e tomar decis\u00f5es informadas com base em seu conhecimento e nas suas percep\u00e7\u00f5es (Russell, 2010). Por exemplo, um carro aut\u00f4nomo \u00e9 um agente inteligente que utiliza sensores para perceber obst\u00e1culos na estrada e agir para evit\u00e1-los. </p> <p> O termo \"percepto\" \u00e9 usado para descrever os dados que os sensores de um agente captam do ambiente. J\u00e1 a sequ\u00eancia de percep\u00e7\u00e3o de um agente representa o hist\u00f3rico completo de tudo o que ele registrou at\u00e9 o momento (Russell, 2010).  </p> <p></p> Componentes da arquitetura de agentes Arquitetura do Agente <p> A arquitetura de um agente \u00e9 a base que permite sua opera\u00e7\u00e3o e intera\u00e7\u00e3o com o ambiente. Ela pode ser tanto f\u00edsica quanto digital, dependendo do tipo de agente em quest\u00e3o (Russell, 2010). Cada tipo de agente requer uma arquitetura personalizada, adaptada \u00e0s suas necessidades de intera\u00e7\u00e3o com o ambiente e \u00e0 execu\u00e7\u00e3o de suas tarefas espec\u00edficas. A escolha da arquitetura \u00e9 crucial para o sucesso do agente, pois ela determina como ele ser\u00e1 capaz de perceber seu ambiente e agir sobre ele para atingir seus objetivos (AWS, 2024).  </p> Fun\u00e7\u00e3o do Agente <p> A fun\u00e7\u00e3o de um agente \u00e9 a l\u00f3gica que conecta as percep\u00e7\u00f5es recebidas pelo agente com as a\u00e7\u00f5es que ele deve realizar para alcan\u00e7ar seus objetivos (AWS, 2024). Em outras palavras, \u00e9 a tradu\u00e7\u00e3o dos dados coletados pelo agente em a\u00e7\u00f5es pr\u00e1ticas que o movem em dire\u00e7\u00e3o \u00e0 sua meta (AWS, 2024). A efici\u00eancia e efic\u00e1cia do agente dependem diretamente de uma fun\u00e7\u00e3o bem projetada, que permita que o agente se adapte e tome decis\u00f5es apropriadas com base nas percep\u00e7\u00f5es e nas mudan\u00e7as em seu ambiente (Russell, 2010). </p> Programa do Agente <p> O programa do agente \u00e9 a implementa\u00e7\u00e3o concreta da fun\u00e7\u00e3o do agente dentro de sua arquitetura (AWS, 2024). Trata-se do c\u00f3digo de software que executa as a\u00e7\u00f5es do agente de acordo com a l\u00f3gica estabelecida em sua fun\u00e7\u00e3o (AWS, 2024).  O desenvolvimento do programa de agente envolve a cria\u00e7\u00e3o, treinamento e implanta\u00e7\u00e3o do sistema, garantindo que ele possa operar de forma aut\u00f4noma e eficiente (Russell, 2010). Durante o processo de implementa\u00e7\u00e3o, o programa de agente deve ser capaz de processar entradas, tomar decis\u00f5es baseadas nas percep\u00e7\u00f5es e executar a\u00e7\u00f5es que o aproximem de seu objetivo. Esse programa integra a l\u00f3gica de neg\u00f3cios, os requisitos t\u00e9cnicos e os elementos de performance do agente, sendo essencial para garantir que o agente funcione corretamente dentro do contexto para o qual foi projetado (Russell, 2010). </p> Descri\u00e7\u00e3o PEAS <p> A descri\u00e7\u00e3o PEAS (Performance, Environment, Actuators, Sensors) \u00e9 um modelo usado para especificar o ambiente de tarefas de um agente (Russell, 2010). Ela envolve quatro componentes principais: </p> <ul> <li> Medida de Performance: Define os objetivos do agente e como seu desempenho ser\u00e1 avaliado. Por exemplo, no caso de um taxista automatizado, isso poderia incluir alcan\u00e7ar o destino correto, minimizar o consumo de combust\u00edvel e o tempo de viagem, ou garantir a seguran\u00e7a dos passageiros. </li> <li> Ambiente: Refere-se ao mundo onde o agente opera e interage. Para um taxista automatizado, isso inclui diferentes tipos de vias, tr\u00e1fego, pedestres e outros obst\u00e1culos que o agente precisa gerenciar. </li> <li> Atuadores: S\u00e3o os mecanismos atrav\u00e9s dos quais o agente realiza a\u00e7\u00f5es no ambiente, como os motores de um carro ou os controles de um jogo. </li> <li> Sensores: Permitem que o agente perceba seu ambiente, como c\u00e2meras ou sensores de movimento em um carro ou sensores de posi\u00e7\u00e3o no jogo. </li> </ul> Propriedades do Ambiente de Tarefas <p> Segundo Ressull, as propriedades do ambiente podem ser divididas em: </p> <ul> <li>Ambiente Totalmente Observ\u00e1vel vs. Parcialmente Observ\u00e1vel: Em um ambiente totalmente observ\u00e1vel, o agente tem acesso a todas as informa\u00e7\u00f5es necess\u00e1rias para tomar decis\u00f5es, sem precisar adivinhar ou inferir nada, ou seja, o agente sabe exatamente o que est\u00e1 acontecendo em cada momento.J\u00e1 em um ambiente parcialmente observ\u00e1vel, o agente n\u00e3o tem acesso a todas as informa\u00e7\u00f5es e precisa fazer suposi\u00e7\u00f5es ou usar estrat\u00e9gias para preencher as lacunas. Isso acontece quando o agente tem uma vis\u00e3o limitada do ambiente </li> <li>Ambiente de Agente \u00danico vs. Multiagente: Um ambiente de agente \u00fanico envolve apenas um agente que interage com o ambiente, sem considerar outras entidades como participantes ativos.Em ambientes multiagente, m\u00faltiplos agentes interagem, o que pode incluir situa\u00e7\u00f5es cooperativas ou competitivas. </li> <li>Ambiente Determin\u00edstico vs. Nondetermin\u00edstico: Em um ambiente determin\u00edstico, o estado futuro do ambiente \u00e9 totalmente previs\u00edvel a partir do estado atual e das a\u00e7\u00f5es tomadas. J\u00e1 os ambientes nondetermin\u00edsticos apresentam incerteza sobre o impacto das a\u00e7\u00f5es, tornando dif\u00edcil prever o estado futuro.</li> <li>Ambiente Epis\u00f3dico vs. Sequencial: Ambientes epis\u00f3dicos se caracterizam por tarefas em que as decis\u00f5es tomadas em uma fase n\u00e3o afetam as decis\u00f5es ou o resultado de fases subsequentes. Em ambientes sequenciais, as decis\u00f5es em um momento afetam o futuro.</li> <li>Ambiente Est\u00e1tico vs. Din\u00e2mico: Em um ambiente est\u00e1tico, nada muda enquanto o agente est\u00e1 decidindo o que fazer. Ou seja, o ambiente permanece igual durante o tempo em que o agente pensa ou age. J\u00e1 em um ambiente din\u00e2mico, o ambiente muda enquanto o agente ainda est\u00e1 pensando ou tomando decis\u00f5es. Isso significa que o agente precisa agir rapidamente porque o que est\u00e1 acontecendo ao seu redor pode mudar.</li> <li>Ambiente Discreto vs. Cont\u00ednuo: Ambientes discretos t\u00eam um n\u00famero finito de estados poss\u00edveis, e as a\u00e7\u00f5es podem ser contadas e definidas claramente. Em ambientes cont\u00ednuos, o estado do ambiente e as a\u00e7\u00f5es s\u00e3o representados por valores que podem variar de forma cont\u00ednua</li> <li>Ambiente Conhecido vs. Desconhecido: Em um ambiente conhecido, todos os aspectos do ambiente s\u00e3o bem compreendidos e o agente pode tomar decis\u00f5es baseadas em um conjunto claro de regras. Em um ambiente desconhecido, o agente pode n\u00e3o ter informa\u00e7\u00f5es completas ou precisas sobre como o ambiente funciona, necessitando de aprendizado ou experimenta\u00e7\u00e3o para tomar boas decis\u00f5es.</li> </ul> Exemplo - Sensor de Cadeira de Rodas Componente Descri\u00e7\u00e3o Medida de Desempenho Precis\u00e3o na detec\u00e7\u00e3o de obst\u00e1culos: Minimizar o n\u00famero de colis\u00f5es ou acidentes com obst\u00e1culos.  Efici\u00eancia na navega\u00e7\u00e3o: Maximizar a capacidade de a cadeira de rodas se mover sem interrup\u00e7\u00f5es ou contratempos.  Tempo de resposta: Reduzir o tempo entre a detec\u00e7\u00e3o de um obst\u00e1culo e a a\u00e7\u00e3o corretiva.  Adaptabilidade: Ajustar a rea\u00e7\u00e3o do sensor a diferentes tipos de obst\u00e1culos e ambientes. Ambiente Superf\u00edcie onde a cadeira de rodas se move: Cal\u00e7adas, rampas, ruas, etc.  Obst\u00e1culos no caminho: M\u00f3veis, portas, buracos, obst\u00e1culos baixos como fios ou objetos ca\u00eddos.  Condi\u00e7\u00f5es do ambiente: Ilumina\u00e7\u00e3o, espa\u00e7o dispon\u00edvel para manobra, presen\u00e7a de outros indiv\u00edduos.  Sensores de proximidade: Para detectar obst\u00e1culos nas rotas poss\u00edveis. Atuadores Sistemas de alerta: Sons ou luzes que alertam o usu\u00e1rio sobre a presen\u00e7a de obst\u00e1culos.  Motor de controle da cadeira: Ajusta a dire\u00e7\u00e3o ou a velocidade da cadeira em resposta ao feedback do sensor.  Freio autom\u00e1tico: O sistema pode automaticamente parar a cadeira para evitar colis\u00f5es. Sensores Sensores de proximidade: Detectam obst\u00e1culos pr\u00f3ximos \u00e0 cadeira de rodas (por exemplo, sensores ultrass\u00f4nicos ou infravermelhos).  Sensores de inclina\u00e7\u00e3o: Detectam se a cadeira de rodas est\u00e1 em uma posi\u00e7\u00e3o inst\u00e1vel ou inclinada, ajustando automaticamente a orienta\u00e7\u00e3o.  Sensores de movimento: Detectam o movimento da cadeira e ajustam os comandos com base na velocidade ou dire\u00e7\u00e3o.  Sensores de press\u00e3o: Verificam a presen\u00e7a de obst\u00e1culos que n\u00e3o s\u00e3o detectados visualmente, como fios no ch\u00e3o. Propriedade Justificativa Completamente observ\u00e1vel O sensor de cadeira de rodas precisa captar todos os elementos relevantes ao seu redor (obst\u00e1culos e outros fatores ambientais) para garantir seguran\u00e7a e precis\u00e3o. Isso \u00e9 essencial para evitar colis\u00f5es e garantir que o agente esteja ciente de todas as condi\u00e7\u00f5es ao seu redor. Agente \u00fanico A cadeira de rodas \u00e9 um agente \u00fanico, agindo individualmente para atingir seus objetivos, como evitar obst\u00e1culos e mover-se de maneira eficiente. N\u00e3o h\u00e1 outros agentes competindo ou interagindo diretamente com a cadeira em seu ambiente imediato. N\u00e3o determin\u00edstico O ambiente em que a cadeira de rodas opera pode ser imprevis\u00edvel, com obst\u00e1culos inesperados e condi\u00e7\u00f5es vari\u00e1veis, como mudan\u00e7as na superf\u00edcie (buracos, pedras) ou tr\u00e1fego de pessoas. Isso torna imposs\u00edvel prever com exatid\u00e3o todos os fatores que podem afetar o movimento da cadeira. Sequencial As a\u00e7\u00f5es da cadeira de rodas, como a altera\u00e7\u00e3o de dire\u00e7\u00e3o ou a velocidade, afetam o estado futuro do ambiente, como a posi\u00e7\u00e3o do agente e a intera\u00e7\u00e3o com obst\u00e1culos. A cadeira de rodas precisa considerar como suas a\u00e7\u00f5es atuais influenciam os pr\u00f3ximos estados do ambiente e as rea\u00e7\u00f5es necess\u00e1rias. Din\u00e2mico O ambiente onde a cadeira de rodas opera est\u00e1 constantemente mudando. Obst\u00e1culos podem ser movidos, pessoas podem aparecer de repente, e as condi\u00e7\u00f5es da superf\u00edcie (como inclina\u00e7\u00e3o ou buracos) podem mudar. Isso exige que o agente se adapte em tempo real \u00e0s mudan\u00e7as que acontecem ao seu redor. Cont\u00ednuo O movimento da cadeira de rodas ocorre de forma cont\u00ednua. A cadeira n\u00e3o muda de estado de forma abrupta, mas sim de forma gradual, com varia\u00e7\u00f5es constantes na dire\u00e7\u00e3o e na velocidade, dependendo das percep\u00e7\u00f5es em tempo real do ambiente ao redor. Desconhecido Embora a cadeira de rodas tenha sensores para detectar obst\u00e1culos e outras condi\u00e7\u00f5es ao seu redor, o ambiente pode ser parcialmente desconhecido, especialmente em rela\u00e7\u00e3o a obst\u00e1culos tempor\u00e1rios ou situa\u00e7\u00f5es inesperadas. O sistema de navega\u00e7\u00e3o precisa aprender e adaptar-se a essas situa\u00e7\u00f5es \u00e0 medida que ocorrem."},{"location":"modulo1/historico/","title":"Hist\u00f3rico","text":"Hist\u00f3rico da IA <p> O in\u00edcio da Intelig\u00eancia Artificial (IA) pode ser tra\u00e7ado at\u00e9 o trabalho pioneiro de Warren McCulloch e Walter Pitts em 1943 (Gomes, 2010). Inspirados pela fisiologia dos neur\u00f4nios, a l\u00f3gica proposicional de Russell e Whitehead e a teoria da computa\u00e7\u00e3o de Turing, eles propuseram um modelo de neur\u00f4nios artificiais, onde cada neur\u00f4nio era caracterizado como \u201cligado\u201d ou \u201cdesligado\u201d (Russell, 2016). Demonstraram que redes de neur\u00f4nios artificiais poderiam implementar fun\u00e7\u00f5es comput\u00e1veis e opera\u00e7\u00f5es l\u00f3gicas como AND, OR e NOT, al\u00e9m de sugerirem que essas redes poderiam aprender (Russell, 2016). </p> <p> Alan Turing, considerado um dos pioneiros da IA, trouxe avan\u00e7os significativos com seu artigo de 1950, \"Computing Machinery and Intelligence\"(Barbosa; Bezerra, 2020). Ele inventou um jogo, chamado Teste de Turing, onde um computador conversava com uma pessoa. Se a pessoa n\u00e3o conseguisse dizer quem era quem, quer dizer que o computador era muito inteligente e parecia mesmo uma pessoa. Ele tamb\u00e9m imaginou que os computadores poderiam aprender sozinhos, como as crian\u00e7as, e ficar cada vez mais espertos (Barbosa; Bezerra, 2020).  </p> <p> Na d\u00e9cada de 1950, as pessoas come\u00e7aram a criar m\u00e1quinas que pensavam como o c\u00e9rebro humano, como o SNARC criado por Marvin Minsky e Dean Edmonds (Russell, 2016). Depois, em 1956, um grupo de cientistas muito importantes se juntou para falar sobre como fazer m\u00e1quinas aprender, entender a linguagem e resolver problemas como a gente durante a Confer\u00eancia de Dartmouth, liderada por John McCarthy (Barbosa; Bezerra, 2020). Esse foi o momento em que surgiu o termo \"intelig\u00eancia artificial\" (Barbosa; Bezerra, 2020). As ideias que surgiram desses experimentos e a empolga\u00e7\u00e3o das pessoas fizeram com que cientistas, empresas e governos investissem muito dinheiro em pesquisas sobre intelig\u00eancia artificial,  incluindo a Ag\u00eancia de Pesquisa de Projetos Avan\u00e7ados (ARPA), a mesma institui\u00e7\u00e3o que desenvolveu a internet (Barbosa; Bezerra, 2020). </p> <p> Em 1964, surgiu Eliza, o primeiro chatbot, criado por Joseph Weizenbaum no MIT. O programa simulava uma psicanalista, usando palavras-chave e frases emp\u00e1ticas, e chegou a ser visto como um poss\u00edvel apoio em tratamentos psicol\u00f3gicos (Barbosa; Bezerra, 2020). </p> <p> As previs\u00f5es excessivamente otimistas e as altas expectativas dos primeiros pesquisadores de IA, como as feitas por Herbert Simon, criaram uma vis\u00e3o irrealista sobre o verdadeiro potencial da tecnologia (Russell, 2016). A confian\u00e7a excessiva de Simon foi alimentada pelo desempenho promissor dos primeiros sistemas de IA em problemas simples. Por exemplo, ele previu que, em apenas 10 anos, um computador se tornaria campe\u00e3o de xadrez, mas isso s\u00f3 ocorreu 40 anos depois (Russell, 2016). No entanto, essas previs\u00f5es n\u00e3o se concretizaram como esperado, e muitos sistemas de IA falharam em lidar com problemas mais complexos, principalmente devido \u00e0 falta de uma an\u00e1lise aprofundada dos desafios e \u00e0 subestima\u00e7\u00e3o das limita\u00e7\u00f5es computacionais. A discrep\u00e2ncia entre as expectativas e a realidade resultou em investimentos exagerados, particularmente em sistemas especialistas, que, ao n\u00e3o cumprirem suas promessas, levaram ao decl\u00ednio do interesse e, eventualmente, ao \"inverno da IA\" (Russell, 2016). </p> Sistemas Especialistas <p> Sistemas especialistas s\u00e3o programas de computador projetados para emular o conhecimento e o racioc\u00ednio de especialistas humanos em \u00e1reas espec\u00edficas (Mendes, 1997). Esses sistemas s\u00e3o baseados em conhecimento, utilizando principalmente regras que reproduzem o saber de peritos para resolver problemas em campos como medicina, engenharia e biblioteconomia (Mendes, 1997). A \u00e1rea m\u00e9dica, em particular, foi uma das primeiras a se beneficiar dessa tecnologia, pois envolve problemas complexos que podem ser modelados com regras e heur\u00edsticas. </p> Estrutura B\u00e1sica de um Sistema Especialista segundo Raquel Mendes: <ul> <li>Base de Conhecimento: Cont\u00e9m regras e fatos que representam o conhecimento do especialista. Ela interage com o motor de infer\u00eancia e com o usu\u00e1rio para ajudar a identificar problemas e sugerir solu\u00e7\u00f5es.</li> <li>Motor de Infer\u00eancia: \u00c9\u00e9 a ferramenta que faz um sistema especialista funcionar. Ele pega as informa\u00e7\u00f5es que o sistema tem (fatos e regras) e as combina de diferentes maneiras para encontrar a melhor solu\u00e7\u00e3o para um problema, buscando pensar da mesma forma que um humano. Ele pode utilizar racioc\u00ednio progressivo (quando o sistema recebe informa\u00e7\u00f5es do usu\u00e1rio e as utiliza para encontrar a solu\u00e7\u00e3o) ou regressivo (quando o sistema parte de uma solu\u00e7\u00e3o e busca informa\u00e7\u00f5es para valid\u00e1-la).</li> <li>Interface com o Usu\u00e1rio: \u00c9 a parte do sistema que permite a intera\u00e7\u00e3o entre o usu\u00e1rio e o sistema. Uma interface bem projetada facilita a navega\u00e7\u00e3o e a consulta \u00e0 base de conhecimento, tornando o processo de solu\u00e7\u00e3o de problemas mais eficiente. </li> </ul> Vantagens segundo Raquel Mendes: <ul> <li>Capacidade de distribuir o conhecimento especializado, tornando-o acess\u00edvel a um n\u00famero maior de pessoas.</li> <li>Esses sistemas aumentam a produtividade, pois permitem que usu\u00e1rios acessem rapidamente um vasto conhecimento que normalmente levaria muito tempo para ser aprendido.</li> <li>Redu\u00e7\u00e3o da depend\u00eancia de especialistas, j\u00e1 que o conhecimento pode ser armazenado e acessado por meio do sistema, o que diminui a vulnerabilidade das organiza\u00e7\u00f5es em situa\u00e7\u00f5es cr\u00edticas.</li> <li>S\u00e3o eficazes para treinamento, oferecendo suporte imediato e adaptando-se ao desempenho do usu\u00e1rio.</li> </ul> <p>Acesse os conte\u00fados sobre:</p> <ul> <li>Redes Neurais (1986-presente);</li> <li>Big Data (2001-presente);</li> <li>Deep learning (2011\u2013presente);</li> </ul>"},{"location":"modulo1/limitacoes/","title":"Limita\u00e7\u00f5es, riscos e \u00e9tica","text":"Limita\u00e7\u00f5es da Intelig\u00eancia Artificial <p> A Intelig\u00eancia Artificial apresenta um grande potencial para transformar a sociedade, mas tamb\u00e9m traz consigo riscos significativos. A possibilidade de que a Intelig\u00eancia Artificial (IA) ultrapasse a intelig\u00eancia humana e se torne aut\u00f4noma \u00e9 um tema recorrente em debates futuristas. Cientistas, como Stephen Hawking, expressaram preocupa\u00e7\u00e3o com o cen\u00e1rio em que m\u00e1quinas superinteligentes, capazes de se autoaperfei\u00e7oar, possam escapar do controle humano, conceito chamado singularidade tecnol\u00f3gica (Candiotto &amp; Karasinski, 2022). Segundo Hawking, a falta de alinhamento entre os objetivos das m\u00e1quinas e os nossos poderia representar um risco significativo para a humanidade (Candiotto &amp; Karasinski, 2022). </p> <p> Inicialmente, os criadores do fon\u00f3grafo o conceberam como um meio de registrar as \u00faltimas vontades de indiv\u00edduos em estado terminal. O r\u00e1dio, por sua vez, era visto como um instrumento para levar cultos religiosos a comunidades rurais. J\u00e1 a internet, surgida no p\u00f3s-Segunda Guerra Mundial, foi desenvolvida com o objetivo de garantir um backup de dados, mesmo em caso de outra guerra nuclear (Candiotto &amp; Karasinski, 2022). Para a Intelig\u00eancia Artificial, tamb\u00e9m existe essa dualogia em que para muitos ela seria a solu\u00e7\u00e3o para os maiores desafios da humanidade, enquanto outros a veem como uma amea\u00e7a existencial (Candiotto &amp; Karasinski, 2022).  </p> Quest\u00f5es \u00c9ticas <p> A intelig\u00eancia artificial (IA) apresenta avan\u00e7os revolucion\u00e1rios, mas seu desenvolvimento e aplica\u00e7\u00e3o trazem desafios \u00e9ticos significativos. Entre eles, destaca-se o problema da privacidade de dados, especialmente em um contexto de depend\u00eancia do Big Data e de crescente preocupa\u00e7\u00e3o com a ciberseguran\u00e7a. (Rossett;Angeluci, 2021) </p> <p> A principal limita\u00e7\u00e3o t\u00e9cnica da IA est\u00e1 na sua depend\u00eancia de dados e algoritmos programados por humanos, que, mesmo em sistemas de aprendizado profundo, podem herdar vieses ou limita\u00e7\u00f5es \u00e9ticas de seus criadores (Rossett;Angeluci, 2021). </p> <p></p> <p> Os Sete Problemas \u00c9ticos Algor\u00edtmicos, conforme descrito no ensaio \u00c9tica Algor\u00edtmica: quest\u00f5es e desafios \u00e9ticos do avan\u00e7o tecnol\u00f3gico da sociedade da informa\u00e7\u00e3o  (Rossett;Angeluci, 2021) abrangem problemas relacionados \u00e0 forma como os algoritmos s\u00e3o projetados, implementados e aplicados em diversos contextos, afetando indiv\u00edduos e a sociedade. Os setes problemas descitos s\u00e3o: <ul> <li>Falibilidade do Algoritmo: Algoritmos n\u00e3o s\u00e3o infal\u00edveis e podem produzir resultados errados ou imprecisos, especialmente quando baseados em dados inadequados ou incompletos.</li> <li>Opacidade do Algoritmo: Muitos sistemas algor\u00edtmicos operam como \"caixas-pretas\", dificultando a compreens\u00e3o de como as decis\u00f5es s\u00e3o tomadas, o que compromete a transpar\u00eancia.</li> <li>Vi\u00e9s do Algoritmo: Os algoritmos podem refletir preconceitos presentes nos dados de treinamento ou em sua programa\u00e7\u00e3o, reproduzindo desigualdades existentes.</li> <li>Discrimina\u00e7\u00e3o do Algoritmo: Algumas decis\u00f5es algor\u00edtmicas podem levar a discrimina\u00e7\u00f5es injustas, mesmo que de forma n\u00e3o intencional, ao impactar negativamente determinados grupos.</li> <li>Autonomia nos Algoritmos de Tomada de Decis\u00e3o: Algoritmos com alto grau de autonomia podem tomar decis\u00f5es que escapam ao controle humano direto, gerando incertezas sobre sua confiabilidade e consequ\u00eancias.</li> <li>Privacidade no Algoritmo: O uso de algoritmos frequentemente depende de grandes quantidades de dados pessoais, levantando preocupa\u00e7\u00f5es sobre a coleta, o armazenamento e o uso dessas informa\u00e7\u00f5es.</li> <li>Responsabilidade do Algoritmo: Com a crescente complexidade dos sistemas algor\u00edtmicos, torna-se desafiador determinar quem deve ser responsabilizado por erros ou danos causados pelas decis\u00f5es autom\u00e1ticas.</li> </ul> </p>"},{"location":"modulo1/referencias/","title":"Refer\u00eancias","text":"Refer\u00eancias <p>AMARA, Hudson; GASPAROTTO, Angelita. Intelig\u00eancia Artificial: o uso da rob\u00f3tica na ind\u00fastria 4.0. 2021. Dispon\u00edvel em: https://revista.fatectq.edu.br/interfacetecnologica/article/download/1107/643.</p> <p>Amazon Web Services (AWS). O que s\u00e3o agentes de IA?. 2024. Dispon\u00edvel em: https://aws.amazon.com/pt/what-is/ai-agents/</p> <p>Barbosa, X\u00eania; Bezerra, Ruth. BREVE INTRODU\u00c7\u00c3O \u00c0 HIST\u00d3RIA DA INTELIG\u00caNCIA ARTIFICIAL. 2020. Dispon\u00edvel em: https://periodicos.ufac.br/index.php/jamaxi/article/view/4730/2695</p> <p>Candiotto, Kleber; Karasinski, Murilo. Intelig\u00eancia Artificial e os Riscos Existenciais Reais: Uma An\u00e1lise das Limita\u00e7\u00f5es Humanas de Controle. 2022. Dispon\u00edvel em: https://www.scielo.br/j/fun/a/8ZkDztFLSmkJj6VQqdkpnxh/#</p> <p>Camargo-Vega, J. J., Camargo-Ortega, J. F., &amp; Joyanes-Aguilar, L. Conociendo Big Data. 2015. Revista de la Facultad de Ingenier\u00eda, 24(38), Tunja. Dispon\u00edvel em: http://www.scielo.org.co/scielo.php?pid=S0121-11292015000100006&amp;script=sci_arttext</p> <p>FLECK, Leandro; TAVARES, Maria Herm\u00ednia Ferreira; EYNG, Eduardo; HELMANN, Andrieli Cristina; ANDRADE, Min\u00e9ia Aparecida de Moares. Redes neurais artificiais: princ\u00edpios b\u00e1sicos. Revista Eletr\u00f4nica Cient\u00edfica Inova\u00e7\u00e3o e Tecnologia, v. 1, n. 13, p. 47-57, jan./jun. 2016. Dispon\u00edvel em: https://d1wqtxts1xzle7.cloudfront.net/57830283/4330-15577-1-PB-libre.pdf?1542898208=&amp;response-content-disposition=inline%3B+filename%3DREDES_NEURAIS_ARTIFICIAIS_PRINCIPIOS_BAS.pdf&amp;Expires=1732036317&amp;Signature=AWLG6MlOyHsuwcBQv0RFoKIevN9yFkQQbjbqnlIh4yA-ys1Ri-GMrB2pv4YJxQFlNFafu00zG8i4pevX~IyJSXTxFMdf1NNJ6QB7AYYuo6K-VVIcNX2iW8zKIkNH5-mb5wI6ZknqEnQr6~lOmE4nfq7IsCD-Dc8Gzoovn2q0q-ZYOpTW6M3CiAwb8xUo22GpjWlc-pPohdNtkx0I2ry4drwVgE9HpB0ufNJzxBCcZa6Bk9W9ApJJ8Q0OgEbeYwDV3n94rW~UCc75unfzK0eFLPDClvu9ElYKcrvYRqLj4fhIxmrNmDbI-ekH7uQ7RpvxMjwB76wPVbzzRm7t5OCw8w__&amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA</p> <p>GOOGLE. Introduction to AI and Machine Learning on Google Cloud. Google Cloud Skills Boost, 2024. Dispon\u00edvel em: https://www.cloudskillsboost.google/course_templates/593.</p> <p>Gomes, Dennis. Intelig\u00eancia Artificial: Conceitos e Aplica\u00e7\u00f5es. 2010. Dispon\u00edvel em: https://www.professores.uff.br/screspo/wp-content/uploads/sites/127/2017/09/ia_intro.pdf</p> <p>JEFFERY, Oliver. Explain Artificial Intelligence and History of Artificial Intelligence. 2022. Dispon\u00edvel em: https://www.researchgate.net/publication/365472399_Explain_Artificial_Intelligence_and_History_of_Artificial_Intelligence.</p> <p>LeCun, Y., Bengio, Y. &amp; Hinton, G. Deep learning. Nature 521, 436\u2013444. 2015. Dispon\u00edvel em: https://www.nature.com/articles/nature14539</p> <p>Mendes, Raquel. INTELIG\u00caNCIA ARTIFICIAL: SISTEMAS ESPECIALISTAS NO GERENCIAMENTO DA INFORMA\u00c7\u00c3O. 1997. Dispon\u00edvel em: https://www.scielo.br/j/ci/a/MqGHKkTLcPxhhjgpDz9ZNNd/?lang=pt&amp;format=html#</p> <p>RIS-ALA, R. Fundamentos de Aprendizagem por Refor\u00e7o. 2023. Rafael Ris-Ala.</p> <p>Rossetti, R., &amp; Angeluci, A. \u00c9tica Algor\u00edtmica: quest\u00f5es e desafios \u00e9ticos do avan\u00e7o tecnol\u00f3gico da sociedade da informa\u00e7\u00e3o. 2021. Dispon\u00edvel em: https://www.scielo.br/j/gal/a/R9F45HyqFZMpQp9BGTfZnyr/?lang=pt#</p> <p>RUSSELL, Stuart J.; NORVIG, Peter. Artificial Intelligence: A Modern Approach. 3. ed. Upper Saddle River: Prentice Hall, 2016.</p> <p>Stanford University. AI Index Report. 2024. Dispon\u00edvel em: https://hai.stanford.edu/research/ai-index-report</p> <p>SHEIKH, H.; PRINS, C.; SCHRIJVERS, E. Artificial Intelligence: Definition and Background. In: Mission AI. Dispon\u00edvel em: https://link.springer.com/chapter/10.1007/978-3-031-21448-6_2.</p> <p>Sousa, Rebeca. An\u00e1lise da ploidia de embri\u00f5es humanos por meio da Intelig\u00eancia Artificial com o uso de vari\u00e1veis de morfologia, morfocin\u00e9tica e vari\u00e1veis relacionadas com a paciente. 2022. Dispon</p>"},{"location":"modulo2/agente/","title":"Agente de solu\u00e7\u00f5es de problemas","text":"Considera\u00e7\u00f5es Iniciais <p>O tema dos agentes de solu\u00e7\u00e3o de problemas na intelig\u00eancia artificial desperta grande interesse, pois apresenta um equil\u00edbrio entre teoria e aplica\u00e7\u00e3o pr\u00e1tica. Antes de aprofundar no assunto, as aulas da mat\u00e9ria proporcionaram uma vis\u00e3o inicial sobre como esses agentes funcionam como componentes essenciais para resolver problemas em ambientes complexos e din\u00e2micos. At\u00e9 o momento, entendi que eles operam com base na formula\u00e7\u00e3o de objetivos e problemas, executando estrat\u00e9gias de busca e planejamento para alcan\u00e7ar resultados otimizados. Essa abordagem me ajudou a compreender a import\u00e2ncia de conceitos como estados, a\u00e7\u00f5es, algoritmos de busca e heur\u00edsticas, frequentemente utilizados em aplica\u00e7\u00f5es como jogos, sistemas de recomenda\u00e7\u00e3o e rob\u00f3tica.  <p>Minhas expectativas s\u00e3o de consolidar esse conhecimento inicial, explorando de forma mais detalhada como diferentes modelos e algoritmos podem ser aplicados a problemas reais. Espero tamb\u00e9m entender melhor a escolha entre busca informada e n\u00e3o informada, assim como as vantagens e limita\u00e7\u00f5es de cada abordagem em cen\u00e1rios diversos. Por fim, estou curiosa para aprofundar a an\u00e1lise dos algoritmos gen\u00e9ticos e sua contribui\u00e7\u00e3o na resolu\u00e7\u00e3o de problemas mais complexos. Acredito que esse estudo permitir\u00e1 conectar a teoria com situa\u00e7\u00f5es pr\u00e1ticas, oferecendo um panorama mais completo e aplic\u00e1vel dos agentes de solu\u00e7\u00e3o de problemas na intelig\u00eancia artificial.   Agente de Solu\u00e7\u00f5es de Problemas   Um agente de solu\u00e7\u00f5es de problemas \u00e9 um componente central no estudo da intelig\u00eancia artificial, projetado para lidar com situa\u00e7\u00f5es onde a sequ\u00eancia de a\u00e7\u00f5es necess\u00e1ria para alcan\u00e7ar um objetivo n\u00e3o \u00e9 evidente de imediato (RUSSELL; NORVIG, 2016). Esse tipo de agente \u00e9 capaz de \"planejar \u00e0 frente\" ao considerar uma sequ\u00eancia de a\u00e7\u00f5es que o conduza ao estado desejado, ou seja, eles analisam o ambiente, formulam problemas e utilizam estrat\u00e9gias de busca para encontrar a melhor solu\u00e7\u00e3o, sendo fundamentais em cen\u00e1rios como planejamento, navega\u00e7\u00e3o e jogos estrat\u00e9gicos. Essa capacidade de previs\u00e3o \u00e9 essencial em ambientes determin\u00edsticos e completamente observ\u00e1veis, onde o agente pode confiar em seu modelo do mundo para alcan\u00e7ar resultados espec\u00edficos.  Estrutura de Funcionamento    O processo de resolu\u00e7\u00e3o de problemas por agentes pode ser dividido em quatro etapas principais segundo Russell e Norvig (2016) no livro Artificial Intelligence: A Modern Approach:  <ol> <li>Formula\u00e7\u00e3o do Objetivo: Identifica\u00e7\u00e3o de um estado final desejado, que orienta as a\u00e7\u00f5es do agente. Por exemplo, um turista em Roma pode definir como objetivo chegar a Londres.</li> <li>Formula\u00e7\u00e3o do Problema: Modelagem abstrata do mundo, considerando estados poss\u00edveis e a\u00e7\u00f5es dispon\u00edveis. Nesse caso, as cidades podem representar os estados e os meios de transporte, como trem ou avi\u00e3o, podem ser as a\u00e7\u00f5es dispon\u00edveis. Para viajar de Roma a Londres, as op\u00e7\u00f5es podem incluir um voo direto ou trens com conex\u00f5es.</li> <li>Busca de Solu\u00e7\u00e3o: UUtiliza\u00e7\u00e3o de algoritmos para encontrar um caminho vi\u00e1vel do estado inicial ao estado objetivo. Por exemplo, para ir de Edimburgo a Londres, o agente pode explorar as op\u00e7\u00f5es de trem direto ou voos com menor tempo de viagem. A escolha da solu\u00e7\u00e3o pode levar em considera\u00e7\u00e3o fatores como custo, tempo ou conveni\u00eancia.</li> <li>Execu\u00e7\u00e3o da Solu\u00e7\u00e3o: Implementa\u00e7\u00e3o da sequ\u00eancia de a\u00e7\u00f5es planejada, como reservar passagens, viajar at\u00e9 a esta\u00e7\u00e3o de trem ou aeroporto, embarcar no transporte escolhido e, finalmente, chegar a Londres.</li> </ol>  Esses agentes s\u00e3o amplamente aplicados em diversas \u00e1reas, como: <ol> <li> Rob\u00f3tica: Planejamento de trajet\u00f3rias para movimenta\u00e7\u00e3o eficiente </li> <li> Sistemas de log\u00edstica: Otimiza\u00e7\u00e3o de rotas de entrega.</li> <li> Jogos: Defini\u00e7\u00e3o de estrat\u00e9gias vencedoras em jogos como xadrez.</li> <li> Sistemas de recomenda\u00e7\u00e3o: Sugest\u00f5es personalizadas baseadas em padr\u00f5es de busca.</li> Modelos de Busca e Algoritmos  <p>Agentes de solu\u00e7\u00f5es de problemas operam em ambientes representados por grafos de estados, onde os v\u00e9rtices simbolizam estados poss\u00edveis e as arestas correspondem \u00e0s a\u00e7\u00f5es dispon\u00edveis (RUSSELL; NORVIG, 2016). As estrat\u00e9gias de busca podem ser divididas em:</p> <ul> <li>Busca n\u00e3o-informada: Explora\u00e7\u00e3o sistem\u00e1tica do espa\u00e7o de estados sem informa\u00e7\u00f5es adicionais sobre a proximidade do objetivo.</li> <li>Busca informada: Utiliza\u00e7\u00e3o de heur\u00edsticas para priorizar estados mais promissores, tornando a busca mais eficiente.</li> </ul> <p>Esses agentes s\u00e3o ideais para resolver problemas complexos que demandam uma an\u00e1lise profunda de alternativas, diferentemente dos agentes reativos, que operam com base em regras de condi\u00e7\u00e3o-a\u00e7\u00e3o (ALGORITMOZ, 2020). O agente recebe a formula\u00e7\u00e3o do problema e o objetivo, busca a sequ\u00eancia de a\u00e7\u00f5es necess\u00e1rias e as executa.</p> <p>Um exemplo cl\u00e1ssico \u00e9 o problema \"F\u00e9rias na Rom\u00eania\", em que o objetivo \u00e9 sair de Arad e chegar a Bucareste. Nesse caso, as cidades representam os estados e as estradas, as a\u00e7\u00f5es. O problema \u00e9 formulado considerando os elementos essenciais:</p> <ul> <li>Estado inicial: Arad.</li> <li>A\u00e7\u00f5es poss\u00edveis (fun\u00e7\u00e3o sucessora): Conex\u00f5es entre cidades.</li> <li>Teste de objetivo: Verifica\u00e7\u00e3o de chegada a Bucareste.</li> <li>Custo do caminho: Dist\u00e2ncias percorridas.</li> </ul> <p>A solu\u00e7\u00e3o \u00f3tima \u00e9 aquela que minimiza o custo do caminho, utilizando uma abstra\u00e7\u00e3o do mundo real representada por um grafo de estados, desempenhando um papel crucial na IA, permitindo resolver problemas complexos de forma eficiente e otimizada (ALGORITMOZ, 2020). Essa abordagem \u00e9 fundamental para os agentes de solu\u00e7\u00f5es de problemas, como detalhado no v\u00eddeo \u201cIntrodu\u00e7\u00e3o \u00e0 IA #6: Agentes de Resolu\u00e7\u00e3o de Problemas\u201d (ALGORITMOZ, 2020). </p>  No contexto da intelig\u00eancia artificial, o algoritmo utilizado para resolver o problema do mundo do aspirador e o problema do caixeiro viajante (TSP) segue abordagens espec\u00edficas, baseadas em estrat\u00e9gias de busca e otimiza\u00e7\u00e3o (RUSSELL; NORVIG, 2016)."},{"location":"modulo2/algoritmos/","title":"Implementa\u00e7\u00e3o de Busca","text":"Implementa\u00e7\u00e3o de Algoritmos em Python DFS - Viagem de IA (Busca em Profundidade)  <p>A busca em profundidade (Depth-First Search) explora o grafo seguindo um caminho at\u00e9 o final, e quando n\u00e3o h\u00e1 mais op\u00e7\u00f5es, volta e tenta outro caminho.</p> <pre><code>def dfs_viagem(graph, inicio, destino):\n    # Usando uma pilha para armazenar os n\u00f3s que precisam ser visitados\n    pilha = [inicio]\n\n    # Dicion\u00e1rio para armazenar os n\u00f3s visitados e o n\u00f3 anterior\n    visitados = {inicio: None}\n\n    while pilha:\n        atual = pilha.pop()\n\n        if atual == destino:\n            # Quando encontrar o destino, reconstrua o caminho\n            return reconstruir_caminho(atual, visitados)\n\n        for vizinho in graph[atual]:\n            if vizinho not in visitados:\n                visitados[vizinho] = atual\n                pilha.append(vizinho)\n\n    # Se n\u00e3o encontrar o destino\n    return None\n\ndef reconstruir_caminho(destino, visitados):\n    caminho = []\n    atual = destino\n\n    while atual is not None:\n        caminho.append(atual)\n        atual = visitados[atual]\n\n    caminho.reverse()  # Inverter o caminho para que ele v\u00e1 do in\u00edcio ao destino\n    return caminho\n</code></pre> <p>A Viagem de Sabrina:</p> <ul> <li>Explora\u00e7\u00e3o: A busca em profundidade \u00e9 como uma jornada pela rede de IA, explorando cada vez mais a fundo.</li> <li>Transporte: A pilha \u00e9 o \"transporte\" de Sabrina, armazenando os n\u00f3s visitados.</li> <li>Mapa: A vari\u00e1vel <code>visitados</code> serve para rastrear as paradas e evitar que Sabrina se perca.</li> <li>Objetivo: O algoritmo explora todos os n\u00f3s poss\u00edveis, sem se preocupar com o caminho mais curto.</li> <li>Retorno: A reconstru\u00e7\u00e3o do caminho permite tra\u00e7ar a rota completa da viagem, da origem ao destino.</li> </ul> <p>Reconstruindo a Jornada:</p> <ul> <li>Caminho de Volta: Quando o destino \u00e9 alcan\u00e7ado, Sabrina utiliza as informa\u00e7\u00f5es da pilha para reconstruir o caminho.</li> <li>Invers\u00e3o: O caminho \u00e9 invertido para mostrar a sequ\u00eancia correta da viagem.</li> </ul> <p>Quando usar DFS:</p> <ul> <li>Explora\u00e7\u00e3o Completa: Ideal para explorar todas as possibilidades em um grafo.</li> <li>Problemas Espec\u00edficos: \u00datil em problemas onde a explora\u00e7\u00e3o completa \u00e9 mais importante que a otimiza\u00e7\u00e3o.</li> </ul> Algoritmo de Busca com Custo Uniforme (UCS) <p>Algoritmo de Busca com Custo Uniforme (Uniform Cost Search - UCS). Este algoritmo \u00e9 uma varia\u00e7\u00e3o da busca em largura, onde, ao inv\u00e9s de explorar todos os n\u00f3s com a mesma prioridade, ele explora os n\u00f3s com o menor custo acumulado at\u00e9 aquele ponto. A ideia principal do UCS \u00e9 explorar caminhos que custam menos para alcan\u00e7ar o objetivo, sem considerar a heur\u00edstica, apenas o custo real acumulado desde o n\u00f3 inicial.</p> <p>Como funciona:</p> <ul> <li>Expans\u00e3o: UCS sempre escolhe o n\u00f3 com o menor custo acumulado para expandir.</li> <li>Fila de Prioridade: Organiza os n\u00f3s a serem explorados com base no custo total.</li> <li>Revis\u00e3o: Atualiza os caminhos se encontrar um caminho com custo menor.</li> </ul> <p>Detalhamento das Fun\u00e7\u00f5es:</p> <ul> <li>uniform_cost_search(graph, start, goal):<ul> <li>Recebe o grafo, o n\u00f3 inicial e o objetivo.</li> <li>Utiliza uma fila de prioridade.</li> <li>A fila garante que o n\u00f3 com menor custo seja explorado primeiro.</li> <li>Atualiza os custos \u00e0 medida que explora novos n\u00f3s.</li> <li>Reconstr\u00f3i o caminho utilizando um dicion\u00e1rio de predecessores.</li> </ul> </li> </ul> <pre><code>import heapq\n\ndef uniform_cost_search(graph, start, goal):\n    \"\"\"\n    Algoritmo de Busca com Custo Uniforme (UCS).\n    A busca explora os n\u00f3s com o menor custo acumulado at\u00e9 o momento.\n\n    graph: Grafo representado como um dicion\u00e1rio onde as chaves s\u00e3o os n\u00f3s e os valores\n           s\u00e3o outros dicion\u00e1rios que representam os vizinhos e os custos de viagem.\n    start: N\u00f3 inicial da busca.\n    goal: N\u00f3 objetivo da busca.\n\n    Retorna: O caminho encontrado entre o n\u00f3 inicial e o objetivo.\n    \"\"\"\n\n    # Fila de prioridade (min-heap) para explorar n\u00f3s com o menor custo acumulado.\n    open_list = []\n    heapq.heappush(open_list, (0, start))  # (custo acumulado, n\u00f3)\n\n    # Dicion\u00e1rio para armazenar os custos acumulados para cada n\u00f3.\n    g_scores = {start: 0}\n\n    # Dicion\u00e1rio para armazenar o n\u00f3 predecessor de cada n\u00f3 para reconstru\u00e7\u00e3o do caminho.\n    came_from = {}\n\n    while open_list:\n        # Pega o n\u00f3 com o menor custo acumulado da fila de prioridade.\n        current_cost, current_node = heapq.heappop(open_list)\n\n        # Se o n\u00f3 objetivo for encontrado, reconstrua o caminho.\n        if current_node == goal:\n            path = []\n            while current_node in came_from:\n                path.append(current_node)\n                current_node = came_from[current_node]\n            path.append(start)  # Adiciona o n\u00f3 inicial ao caminho.\n            return path[::-1]  # Retorna o caminho na ordem correta.\n\n        # Expande os vizinhos do n\u00f3 atual.\n        for neighbor, travel_cost in graph[current_node].items():\n            tentative_cost = current_cost + travel_cost  # Calcula o custo at\u00e9 o vizinho.\n\n            # Se o vizinho n\u00e3o foi explorado ou encontramos um caminho mais barato at\u00e9 ele.\n            if neighbor not in g_scores or tentative_cost &lt; g_scores[neighbor]:\n                g_scores[neighbor] = tentative_cost\n                heapq.heappush(open_list, (tentative_cost, neighbor))\n                came_from[neighbor] = current_node  # Registra o n\u00f3 predecessor.\n\n    # Se o n\u00f3 objetivo n\u00e3o for encontrado, retorna None.\n    return None\n\n\n# Exemplo de uso\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\nstart = 'A'\ngoal = 'D'\n\npath = uniform_cost_search(graph, start, goal)\nprint(\"Caminho encontrado:\", path)\n</code></pre> <p>Explica\u00e7\u00e3o do C\u00f3digo:</p> <ul> <li>Fila de Prioridade: Utilizada para escolher o pr\u00f3ximo n\u00f3 a ser explorado com base no menor custo acumulado.</li> <li>Dicion\u00e1rios:<ul> <li><code>g_scores</code>: Armazena o custo para alcan\u00e7ar cada n\u00f3.</li> <li><code>came_from</code>: Guarda o n\u00f3 anterior para reconstruir o caminho.</li> </ul> </li> <li>Expans\u00e3o de N\u00f3s:<ul> <li>Calcula o custo para cada vizinho.</li> <li>Atualiza o custo e adiciona \u00e0 fila se o novo caminho for mais barato.</li> </ul> </li> <li>Reconstru\u00e7\u00e3o: Reconstroi o caminho a partir do objetivo at\u00e9 o in\u00edcio.</li> <li>Fila de Prioridade: Garante que o caminho encontrado seja o de menor custo.</li> </ul> <p>Complexidade:</p> <ul> <li>Tempo: O(E log V)</li> <li>Espa\u00e7o: O(V + E)</li> </ul> <p>Considera\u00e7\u00f5es:</p> <ul> <li>UCS \u00e9 eficiente para grafos com custos vari\u00e1veis.</li> <li>N\u00e3o utiliza heur\u00edsticas, podendo ser mais lento em grafos grandes.</li> </ul>"},{"location":"modulo2/busca/","title":"Algoritmos de Busca","text":"Algoritmos de Busca: Busca Cega e Busca Informada  Os algoritmos de busca s\u00e3o amplamente utilizados para a solu\u00e7\u00e3o de problemas em sistemas de intelig\u00eancia artificial. Eles consistem na explora\u00e7\u00e3o de espa\u00e7os de estados para encontrar uma solu\u00e7\u00e3o a partir de um estado inicial at\u00e9 um estado objetivo. As abordagens de busca podem ser classificadas em dois tipos principais: busca cega (uninformed search) e busca informada (informed search). (BARROS, 2006)  1. Agente de Solu\u00e7\u00e3o de Problemas  Um agente que resolve problemas por meio de busca passa pelas seguintes etapas (NILSSON, 1980):     <ol> <li>Formula\u00e7\u00e3o de objetivo: o agente define um ou mais objetivos a serem alcan\u00e7ados.</li> <li>Formula\u00e7\u00e3o de problema: o agente descreve os estados e a\u00e7\u00f5es necess\u00e1rias para atingir o objetivo.</li> <li>Busca: antes de executar a\u00e7\u00f5es, o agente simula sequ\u00eancias de a\u00e7\u00f5es em um modelo de estados.</li> <li>Execu\u00e7\u00e3o: as a\u00e7\u00f5es definidas na etapa de busca s\u00e3o realizadas para atingir o estado objetivo.</li> </ol> Esses agentes atuam em ambientes determin\u00edsticos ou n\u00e3o determin\u00edsticos, podendo operar em malha aberta ou malha fechada, dependendo da capacidade de obter feedback do ambiente durante a execu\u00e7\u00e3o (RUSSELL; NORVIG, 2010).  2. Busca Cega (Uninformed Search)  A busca cega, tamb\u00e9m chamada de busca n\u00e3o informada, \u00e9 uma estrat\u00e9gia onde o agente n\u00e3o possui nenhuma informa\u00e7\u00e3o adicional sobre a dist\u00e2ncia at\u00e9 o objetivo, exceto os estados e as a\u00e7\u00f5es poss\u00edveis a partir de cada estado. Ela explora o espa\u00e7o de estados de forma sistem\u00e1tica, sem orienta\u00e7\u00e3o espec\u00edfica (BARROS, 2010).   <ul> <li>Busca em largura (Breadth-First Search \u2013 BFS): explora todos os n\u00f3s de um n\u00edvel antes de avan\u00e7ar para o pr\u00f3ximo.              \u00c9 completa e encontra a solu\u00e7\u00e3o de menor custo, desde que todas as a\u00e7\u00f5es tenham custo uniforme. (NILSSON, 1980)             <ul> <li>Completude: sim</li> <li>Complexidade de tempo:O(b^d)</li> <li>Complexidade de espa\u00e7o:O(b^d)</li> </ul> </li> <li>Busca em profundidade (Depth-First Search \u2013 DFS): explora o caminho at\u00e9 o n\u00edvel mais profundo antes de retroceder.              \u00c9 mais eficiente em termos de mem\u00f3ria, mas n\u00e3o \u00e9 completa para espa\u00e7os infinitos e pode n\u00e3o encontrar a solu\u00e7\u00e3o de menor custo. (BARROS, 2010)             <ul> <li>Completude: n\u00e3o, em espa\u00e7os infinitos</li> <li>Complexidade de tempo: O(b^m)</li> <li>Complexidade de espa\u00e7o: O(bm)</li> </ul> </li> </ul> 3. Busca Informada (Informed Search) <p>     A busca informada, ou heur\u00edstica, utiliza informa\u00e7\u00f5es adicionais sobre o problema para guiar a busca em dire\u00e7\u00e3o ao objetivo      de forma mais eficiente. Essa informa\u00e7\u00e3o \u00e9 fornecida por uma fun\u00e7\u00e3o heur\u00edstica \\( h(n) \\), que estima o custo para atingir o objetivo      a partir do estado atual (RUSSELL; NORVIG, 2010). </p> Principais algoritmos de busca informada <ul> <li>Busca gulosa (Greedy Best-First Search): expande o n\u00f3 que parece mais promissor de acordo com a fun\u00e7\u00e3o heur\u00edstica.          Embora r\u00e1pida, n\u00e3o \u00e9 completa nem \u00f3tima em todos os casos. (BARROS, 2010)         <ul> <li>Completude: n\u00e3o, em todos os casos</li> <li>Otimiza\u00e7\u00e3o de custo: n\u00e3o garante a solu\u00e7\u00e3o de menor custo</li> </ul> </li> <li>Busca A*: combina a busca de custo uniforme e a busca gulosa, utilizando uma fun\u00e7\u00e3o de avalia\u00e7\u00e3o \\( f(n) = g(n) + h(n) \\),          onde \\( g(n) \\) \u00e9 o custo do caminho at\u00e9 o n\u00f3 \\( n \\) e \\( h(n) \\) \u00e9 a estimativa heur\u00edstica do custo restante.          A busca A* \u00e9 completa e \u00f3tima se a heur\u00edstica for admiss\u00edvel. (RUSSELL; NORVIG, 2010)         <ul> <li>Completude: sim</li> <li>Otimiza\u00e7\u00e3o de custo: sim, se \\( h(n) \\) for admiss\u00edvel</li> </ul> </li> </ul>  4. Compara\u00e7\u00e3o: Busca Cega vs. Busca Informada Crit\u00e9rio Busca Cega Busca Informada Uso de informa\u00e7\u00e3o N\u00e3o utiliza informa\u00e7\u00f5es adicionais Utiliza fun\u00e7\u00f5es heur\u00edsticas Efici\u00eancia Menor efici\u00eancia Maior efici\u00eancia 4.1 Mundo do Aspirador  <p>O problema do mundo do aspirador \u00e9 um exemplo cl\u00e1ssico de problema de busca e planejamento, onde um agente (aspirador) deve limpar um conjunto de c\u00e9lulas em uma grade, movendo-se entre elas. O ambiente \u00e9 geralmente representado por uma grade 2D, onde algumas c\u00e9lulas est\u00e3o sujas e outras limpas. O agente tem a capacidade de se mover para dire\u00e7\u00f5es espec\u00edficas (como norte, sul, leste e oeste) e limpar a c\u00e9lula em que se encontra, enquanto tenta alcan\u00e7ar o objetivo de limpar todas as c\u00e9lulas do ambiente.</p> <p>A solu\u00e7\u00e3o para esse problema pode ser implementada com um algoritmo de busca como a busca em largura (breadth-first search) ou a busca em profundidade (depth-first search), dependendo da complexidade e dos requisitos de efici\u00eancia. Para um ambiente simples e pequeno, a busca em profundidade pode ser suficiente, onde o agente explora recursivamente suas op\u00e7\u00f5es, movendo-se at\u00e9 uma c\u00e9lula limpa e depois retornando se necess\u00e1rio.</p> <p>Uma abordagem mais sofisticada seria a utiliza\u00e7\u00e3o de algoritmos de planejamento, que consideram as a\u00e7\u00f5es do aspirador como parte de uma sequ\u00eancia planejada de tarefas. O algoritmo de busca A* (A-star) pode ser utilizado aqui, j\u00e1 que ele \u00e9 eficiente para encontrar o caminho mais curto considerando uma heur\u00edstica que aproxima a dist\u00e2ncia do estado atual at\u00e9 o estado objetivo (todas as c\u00e9lulas limpas). Nesse caso, a fun\u00e7\u00e3o de custo pode ser baseada no n\u00famero de c\u00e9lulas que o aspirador precisa limpar, enquanto a heur\u00edstica pode estimar o n\u00famero de c\u00e9lulas sujas restantes.</p> 4.2 Problema do Caixeiro Viajante (TSP)  <p>O problema do caixeiro viajante (TSP) \u00e9 um cl\u00e1ssico problema de otimiza\u00e7\u00e3o, no qual o objetivo \u00e9 encontrar o caminho mais curto que permita a um vendedor visitar um conjunto de cidades e retornar \u00e0 cidade de origem. O TSP \u00e9 um problema NP-dif\u00edcil, o que significa que sua solu\u00e7\u00e3o exata leva um tempo exponencial em rela\u00e7\u00e3o ao n\u00famero de cidades, tornando-o impratic\u00e1vel para grandes conjuntos de cidades. Por esse motivo, solu\u00e7\u00f5es aproximadas e heur\u00edsticas s\u00e3o frequentemente usadas.</p> <p>Uma das abordagens mais comuns para resolver o TSP \u00e9 o algoritmo de for\u00e7a bruta, que gera todas as poss\u00edveis permuta\u00e7\u00f5es das cidades e calcula o custo total de cada uma, selecionando a sequ\u00eancia que resulta no menor custo. Esse m\u00e9todo \u00e9 eficaz para um n\u00famero pequeno de cidades, mas se torna extremamente lento \u00e0 medida que o n\u00famero de cidades cresce, j\u00e1 que o n\u00famero de permuta\u00e7\u00f5es poss\u00edveis \u00e9 fatorial (n!).</p> <p>Uma alternativa mais eficiente \u00e9 o uso de algoritmos de busca local, como o algoritmo de troca 2-opt. Esse m\u00e9todo come\u00e7a com uma solu\u00e7\u00e3o inicial (por exemplo, uma sequ\u00eancia aleat\u00f3ria de cidades) e tenta melhorar essa solu\u00e7\u00e3o trocando pares de cidades em sua ordem. Se a troca resultar em um caminho de menor custo, ela \u00e9 mantida, e o processo \u00e9 repetido at\u00e9 que n\u00e3o haja mais melhorias poss\u00edveis.</p> <p>Al\u00e9m disso, algoritmos como algoritmos gen\u00e9ticos, simulated annealing e algoritmos de col\u00f4nia de formigas tamb\u00e9m s\u00e3o aplicados ao TSP. Esses m\u00e9todos buscam encontrar boas solu\u00e7\u00f5es aproximadas em um tempo razo\u00e1vel. No caso do algoritmo gen\u00e9tico, uma popula\u00e7\u00e3o de solu\u00e7\u00f5es potenciais \u00e9 evolu\u00edda ao longo do tempo atrav\u00e9s de opera\u00e7\u00f5es como cruzamento e muta\u00e7\u00e3o, sempre selecionando as solu\u00e7\u00f5es com menor custo para formar a pr\u00f3xima gera\u00e7\u00e3o.</p> <p>Por fim, para problemas de TSP com muitas cidades, as solu\u00e7\u00f5es exatas se tornam invi\u00e1veis, e, por isso, a abordagem mais comum \u00e9 o uso de heur\u00edsticas e metaheur\u00edsticas, que garantem encontrar solu\u00e7\u00f5es boas em tempo razo\u00e1vel, embora n\u00e3o necessariamente \u00f3timas.</p>  Em ambos os problemas \u2014 o mundo do aspirador e o caixeiro viajante \u2014 os algoritmos de busca e otimiza\u00e7\u00e3o desempenham um papel fundamental. O mundo do aspirador utiliza algoritmos de busca como a busca em largura e A*, enquanto o TSP, por ser mais complexo, \u00e9 abordado com t\u00e9cnicas como for\u00e7a bruta para problemas pequenos e algoritmos de otimiza\u00e7\u00e3o aproximada (como 2-opt e algoritmos gen\u00e9ticos) para cen\u00e1rios mais desafiadores e com muitas cidades. Ambos os problemas exemplificam como a intelig\u00eancia artificial pode ser aplicada para resolver tarefas de planejamento e otimiza\u00e7\u00e3o em ambientes controlados e do mundo real."},{"location":"modulo2/complexos/","title":"Ambientes Complexos","text":"Busca em Ambientes Complexos <p>A busca em ambientes complexos refere-se ao processo de encontrar solu\u00e7\u00f5es para problemas que envolvem m\u00faltiplas vari\u00e1veis e intera\u00e7\u00f5es entre elas, em contextos que podem ser din\u00e2micos e incertos. Tais problemas s\u00e3o comuns em \u00e1reas como rob\u00f3tica, jogos, log\u00edstica e engenharia. Em ambientes complexos, a busca n\u00e3o se limita \u00e0 simples explora\u00e7\u00e3o de solu\u00e7\u00f5es, mas exige abordagens que considerem n\u00e3o s\u00f3 o espa\u00e7o de estados, mas tamb\u00e9m a adapta\u00e7\u00e3o \u00e0s mudan\u00e7as constantes e incertezas do ambiente (RUSSELL; NORVIG, 2016).</p> <p>Um exemplo cl\u00e1ssico de problema que pode ser abordado por busca em ambientes complexos \u00e9 o Problema do Caixeiro-Viajante, em que um vendedor precisa percorrer v\u00e1rias cidades, buscando o caminho mais curto entre elas. A complexidade dessa busca aumenta exponencialmente \u00e0 medida que o n\u00famero de cidades cresce, exigindo abordagens eficientes para explorar as poss\u00edveis solu\u00e7\u00f5es. Outro exemplo relevante \u00e9 o problema de navega\u00e7\u00e3o em labirintos, no qual um agente precisa encontrar a sa\u00edda em um ambiente que pode ter in\u00fameras configura\u00e7\u00f5es e obst\u00e1culos, demandando uma busca sistem\u00e1tica (RUSSELL; NORVIG, 2016). </p> T\u00e9cnicas de Busca em Ambientes Complexos  <p>Diversas t\u00e9cnicas s\u00e3o empregadas para resolver problemas em ambientes complexos. Entre elas, destacam-se a busca em largura, a busca em profundidade e o algoritmo A*. O algoritmo A*, por exemplo, \u00e9 altamente eficiente para muitos tipos de problemas de busca em ambientes complexos, pois combina a explora\u00e7\u00e3o do caminho percorrido com uma previs\u00e3o do futuro. Ele utiliza uma fun\u00e7\u00e3o heur\u00edstica para estimar o custo do caminho at\u00e9 o objetivo, al\u00e9m de um custo acumulado at\u00e9 o estado atual, formando uma m\u00e9trica f(n) = g(n) + h(n), onde g(n) representa o custo do caminho percorrido e h(n) \u00e9 a heur\u00edstica (RUSSELL; NORVIG, 2016). </p> <p>O algoritmo A* \u00e9 muitas vezes comparado \u00e0 busca Greedy, que se baseia exclusivamente em uma heur\u00edstica, sem considerar o custo acumulado at\u00e9 o momento. Ao contr\u00e1rio da busca Greedy, o A* tenta balancear essas duas informa\u00e7\u00f5es, o que muitas vezes resulta em uma solu\u00e7\u00e3o mais eficiente e precisa, embora possa ser mais lento em rela\u00e7\u00e3o a outras abordagens (RUSSELL; NORVIG, 2016). </p> Busca em Ambientes Din\u00e2micos e de Tempo Real <p> Ambientes complexos muitas vezes s\u00e3o din\u00e2micos, ou seja, as condi\u00e7\u00f5es do ambiente podem mudar rapidamente, o que exige que os algoritmos de busca sejam adapt\u00e1veis e eficientes em tempo real. A busca em tempo real \u00e9 uma dessas abordagens, que permite que decis\u00f5es sejam tomadas rapidamente, mesmo que a explora\u00e7\u00e3o completa do espa\u00e7o de estados n\u00e3o seja poss\u00edvel. Um exemplo disso \u00e9 o algoritmo LRTA (Learning Real-Time A)**, que ajusta sua heur\u00edstica com base no feedback obtido durante a execu\u00e7\u00e3o, aprendendo e se adaptando enquanto resolve o problema (SOARES, 2024). </p> <p> Al\u00e9m disso, modelos preditivos podem ser usados para antecipar mudan\u00e7as no ambiente, ajudando a guiar a busca de forma mais eficiente. No caso de carros aut\u00f4nomos, por exemplo, sensores e algoritmos preditivos combinam dados em tempo real sobre o ambiente para tomar decis\u00f5es r\u00e1pidas, como evitar obst\u00e1culos ou ajustar a rota, garantindo seguran\u00e7a e efici\u00eancia na navega\u00e7\u00e3o. Esses sistemas precisam lidar com incertezas (dados parciais ou imprecisos) e dinamicidade (mudan\u00e7as r\u00e1pidas e constantes) (SOARES, 2024). </p> Desafios na Busca em Ambientes Complexos <p> A busca em ambientes complexos apresenta v\u00e1rios desafios, que incluem a necessidade de lidar com incertezas nos dados, mudan\u00e7as r\u00e1pidas no ambiente e a alta complexidade computacional. Para esses desafios, diversas solu\u00e7\u00f5es podem ser adotadas, como o uso de m\u00faltiplos sensores para diminuir a ambiguidade dos dados, a implementa\u00e7\u00e3o de heur\u00edsticas eficientes para reduzir o custo computacional e a aplica\u00e7\u00e3o de algoritmos adaptativos para responder \u00e0s mudan\u00e7as r\u00e1pidas (SOARES, 2024).  Fun\u00e7\u00f5es Heur\u00edsticas   As fun\u00e7\u00f5es heur\u00edsticas s\u00e3o essenciais para guiar a busca em ambientes complexos. Em problemas como o quebra-cabe\u00e7a com pe\u00e7as que podem se mover apenas na vertical ou horizontal, uma fun\u00e7\u00e3o heur\u00edstica comum \u00e9 o n\u00famero de pe\u00e7as fora do lugar. Essa fun\u00e7\u00e3o \u00e9 admiss\u00edvel, pois cada pe\u00e7a fora do lugar precisa de pelo menos um movimento para ser colocada em sua posi\u00e7\u00e3o correta. Outra fun\u00e7\u00e3o heur\u00edstica utilizada \u00e9 a dist\u00e2ncia de Manhattan, que calcula a soma das dist\u00e2ncias das pe\u00e7as de suas posi\u00e7\u00f5es finais (SOARES, 2024).  Essas fun\u00e7\u00f5es heur\u00edsticas ajudam os algoritmos de busca, como o A*, a explorar de forma mais eficiente o espa\u00e7o de solu\u00e7\u00f5es. No entanto, a escolha de uma boa heur\u00edstica \u00e9 fundamental para garantir que o algoritmo n\u00e3o seja enganado por uma fun\u00e7\u00e3o que superestime ou subestime os custos (SOARES, 2024).  Minhas Considera\u00e7\u00f5es <p> A busca em ambientes complexos \u00e9, sem d\u00favida, um dos pilares fundamentais da intelig\u00eancia artificial, especialmente quando se trata de resolver problemas que envolvem m\u00faltiplas vari\u00e1veis, incertezas e dinamicidade. Ao longo deste estudo, ficou evidente que, embora os algoritmos de busca, como o A*, sejam extremamente poderosos, a escolha da t\u00e9cnica ideal depende fortemente das caracter\u00edsticas do ambiente em que est\u00e3o sendo aplicados.  <p> Em minha opini\u00e3o, o verdadeiro desafio est\u00e1 em adaptar essas t\u00e9cnicas para cen\u00e1rios reais, como no caso dos carros aut\u00f4nomos, onde a precis\u00e3o e a velocidade de decis\u00e3o s\u00e3o essenciais para a seguran\u00e7a e efici\u00eancia do sistema. Al\u00e9m disso, a utiliza\u00e7\u00e3o de fun\u00e7\u00f5es heur\u00edsticas, como o n\u00famero de pe\u00e7as fora do lugar ou a dist\u00e2ncia de Manhattan, tamb\u00e9m destaca a import\u00e2ncia de se escolher fun\u00e7\u00f5es que guiem a busca de forma eficiente, sem sobrecarregar o sistema com c\u00e1lculos desnecess\u00e1rios.  <p> \u00c9 not\u00e1vel que, por mais que tenhamos feito avan\u00e7os significativos, ainda estamos em um ponto onde a combina\u00e7\u00e3o de diferentes abordagens de busca, adaptadas para necessidades espec\u00edficas, seja a chave para o sucesso. Acredito que, \u00e0 medida que a tecnologia evolui, a busca em ambientes complexos continuar\u00e1 a ser uma \u00e1rea de intensivo desenvolvimento, com novas solu\u00e7\u00f5es sendo propostas para lidar com a complexidade crescente dos problemas enfrentados, especialmente com o aumento do uso de IA em sistemas din\u00e2micos e interativos."},{"location":"modulo2/geneticos/","title":"Algoritmos Gen\u00e9ticos","text":"Algoritmos Gen\u00e9ticos <p> Os algoritmos gen\u00e9ticos (AGs) s\u00e3o uma classe de algoritmos inspirados nos processos de evolu\u00e7\u00e3o natural, utilizados para resolver problemas complexos de otimiza\u00e7\u00e3o (BARTZ-BEIELSTEIN et al, 2024). Eles pertencem a uma categoria maior chamada algoritmos evolutivos (AEs), que incluem tamb\u00e9m estrat\u00e9gias evolutivas e programa\u00e7\u00e3o gen\u00e9tica (BARTZ-BEIELSTEIN et al., 2024). O funcionamento b\u00e1sico dos algoritmos gen\u00e9ticos envolve uma popula\u00e7\u00e3o de indiv\u00edduos, representados por um conjunto de poss\u00edveis solu\u00e7\u00f5es para o problema em quest\u00e3o, que se reproduzem e geram descendentes para formar novas gera\u00e7\u00f5es. A sele\u00e7\u00e3o dos indiv\u00edduos mais aptos, ou seja, aqueles que apresentam as melhores solu\u00e7\u00f5es para o problema, \u00e9 feita de acordo com uma fun\u00e7\u00e3o de fitness. Essa fun\u00e7\u00e3o mede a qualidade das solu\u00e7\u00f5es e \u00e9 fundamental para guiar a busca do algoritmo (SOARES, 2024). </p> <p> A estrutura de um AG \u00e9 composta por diversos par\u00e2metros que influenciam seu desempenho, como o tamanho da popula\u00e7\u00e3o, a representa\u00e7\u00e3o dos indiv\u00edduos (a forma como as solu\u00e7\u00f5es s\u00e3o codificadas), o n\u00famero de pais selecionados para cruzamento, a taxa de muta\u00e7\u00e3o e o processo de recombina\u00e7\u00e3o (BARTZ-BEIELSTEIN et al., 2024). O cruzamento, ou recombina\u00e7\u00e3o, mistura as caracter\u00edsticas de dois indiv\u00edduos para gerar descendentes, enquanto a muta\u00e7\u00e3o altera aleatoriamente alguns genes de um indiv\u00edduo para introduzir diversidade na popula\u00e7\u00e3o e evitar que o algoritmo fique preso em \u00f3timos locais. O balanceamento entre recombina\u00e7\u00e3o e muta\u00e7\u00e3o \u00e9 crucial para garantir uma explora\u00e7\u00e3o eficaz do espa\u00e7o de solu\u00e7\u00f5es (BARTZ-BEIELSTEIN et al., 2024). </p> <p> Uma das aplica\u00e7\u00f5es cl\u00e1ssicas dos algoritmos gen\u00e9ticos \u00e9 a resolu\u00e7\u00e3o do problema das 8 damas, onde o objetivo \u00e9 posicionar 8 damas em um tabuleiro de xadrez de forma que nenhuma dama ataque outra (SOARES, 2024). Neste caso, cada solu\u00e7\u00e3o \u00e9 representada por uma configura\u00e7\u00e3o de posi\u00e7\u00f5es das damas, e a fun\u00e7\u00e3o de fitness avalia quantas damas est\u00e3o atacando umas \u00e0s outras, sendo o objetivo minimizar essa quantidade. O uso de AGs nesse contexto demonstra como esses algoritmos podem ser aplicados a problemas de busca combinat\u00f3ria (SOARES, 2024). </p> <p> Os algoritmos gen\u00e9ticos tamb\u00e9m t\u00eam variantes que exploram diferentes formas de representa\u00e7\u00e3o e sele\u00e7\u00e3o. Por exemplo, os algoritmos com representa\u00e7\u00e3o bin\u00e1ria (como strings de bits) s\u00e3o os mais tradicionais, mas outras abordagens, como os algoritmos com representa\u00e7\u00e3o real, podem ser mais eficientes para certos tipos de problemas. A escolha da representa\u00e7\u00e3o adequada \u00e9 uma das decis\u00f5es mais importantes ao projetar um AG, pois ela pode afetar diretamente a efici\u00eancia e a efic\u00e1cia do algoritmo (BARTZ-BEIELSTEIN et al., 2024). </p> <p> Os algoritmos gen\u00e9ticos s\u00e3o ferramentas poderosas para resolver uma ampla gama de problemas de otimiza\u00e7\u00e3o. A sua capacidade de explorar grandes espa\u00e7os de busca de forma eficiente e sua flexibilidade para lidar com problemas complexos, com m\u00faltiplos objetivos e vari\u00e1veis, os torna uma escolha popular em v\u00e1rias \u00e1reas da ci\u00eancia e engenharia. No entanto, o sucesso de um AG depende da cuidadosa escolha dos par\u00e2metros de opera\u00e7\u00e3o e da adapta\u00e7\u00e3o constante do algoritmo durante o processo de busca. O uso equilibrado de cruzamento e muta\u00e7\u00e3o, juntamente com uma representa\u00e7\u00e3o adequada, pode melhorar significativamente o desempenho desses algoritmos (SOARES, 2024; BARTZ-BEIELSTEIN et al., 2024). </p>"},{"location":"modulo2/heuristica/","title":"Fun\u00e7\u00f5es Heur\u00edsticas","text":"Fun\u00e7\u00f5es Heur\u00edsticas <p>Fun\u00e7\u00f5es heur\u00edsticas s\u00e3o fundamentais para otimizar algoritmos de busca informada, ajudando a reduzir o espa\u00e7o de pesquisa ao guiar a busca na dire\u00e7\u00e3o mais promissora. Elas s\u00e3o amplamente utilizadas em problemas complexos, especialmente aqueles com grandes espa\u00e7os de estados, como os encontrados em jogos, planejamento e navega\u00e7\u00e3o. A principal fun\u00e7\u00e3o de uma heur\u00edstica \u00e9 fornecer uma estimativa do custo ou da dist\u00e2ncia at\u00e9 a solu\u00e7\u00e3o desejada a partir de um dado estado, permitindo que o algoritmo de busca tome decis\u00f5es mais estrat\u00e9gicas sobre qual caminho seguir.</p> <p>Uma heur\u00edstica simples pode ser, por exemplo, a dist\u00e2ncia euclidiana em problemas de navega\u00e7\u00e3o, como encontrar o caminho mais curto entre dois pontos em um mapa. A f\u00f3rmula da dist\u00e2ncia direta entre dois pontos pode ser calculada utilizando o teorema de Pit\u00e1goras, oferecendo uma estimativa r\u00e1pida e \u00fatil, mesmo que o caminho real seja mais complexo devido a obst\u00e1culos. Esse tipo de heur\u00edstica \u00e9 considerado admiss\u00edvel, pois nunca superestima o custo real para alcan\u00e7ar o objetivo, garantindo que o algoritmo encontre o caminho mais curto.</p> <p>No caso de algoritmos como o A*, a heur\u00edstica pode assumir diferentes formas dependendo do problema em quest\u00e3o. Em algumas varia\u00e7\u00f5es, \u00e9 poss\u00edvel usar a fun\u00e7\u00e3o h(\ud835\udc5b)=0, que simplifica o c\u00e1lculo de custo, indicando que o custo estimado at\u00e9 o objetivo \u00e9 zero. Essa abordagem \u00e9 \u00fatil em cen\u00e1rios onde o objetivo \u00e9 conhecido e o desafio principal \u00e9 encontrar o caminho mais eficiente at\u00e9 ele.</p>  Existem tr\u00eas caracter\u00edsticas principais que uma heur\u00edstica de qualidade deve possuir para ser eficaz:  <ul> <li>Admissibilidade: A heur\u00edstica nunca deve superestimar o custo real necess\u00e1rio para alcan\u00e7ar a solu\u00e7\u00e3o. Esse requisito \u00e9 essencial para garantir que o algoritmo de busca, como o A*, encontre a solu\u00e7\u00e3o \u00f3tima (algoritmos admiss\u00edveis sempre retornam a melhor solu\u00e7\u00e3o poss\u00edvel) (CAMBUIM, 2020).     <li>Consist\u00eancia ou Monotonicidade: A heur\u00edstica deve satisfazer a condi\u00e7\u00e3o de que o custo estimado de um estado seja menor ou igual ao custo estimado do estado sucessor, somado ao custo da transi\u00e7\u00e3o entre eles. Isso ajuda a evitar ciclos e garante que o algoritmo n\u00e3o reexplore caminhos que j\u00e1 foram considerados.     <li>Efici\u00eancia Computacional: O c\u00e1lculo da heur\u00edstica deve ser r\u00e1pido e simples o suficiente para n\u00e3o sobrecarregar o algoritmo de busca, permitindo uma an\u00e1lise eficiente mesmo em grandes espa\u00e7os de busca.  <p>Exemplificando em um cen\u00e1rio pr\u00e1tico, no jogo de xadrez, fun\u00e7\u00f5es heur\u00edsticas s\u00e3o usadas para avaliar a for\u00e7a de uma posi\u00e7\u00e3o no tabuleiro, orientando algoritmos de decis\u00e3o, como o Minimax. Um exemplo simples de heur\u00edstica seria a contagem de pe\u00e7as valiosas, onde pe\u00e7as como a dama e o cavalo s\u00e3o atribu\u00eddas a valores num\u00e9ricos. Embora essa heur\u00edstica n\u00e3o garanta a melhor jogada em todas as situa\u00e7\u00f5es, ela permite decis\u00f5es r\u00e1pidas e eficazes em situa\u00e7\u00f5es de jogo (CAMBUIM, 2020).</p> <p>As heur\u00edsticas desempenham um papel crucial na melhoria do desempenho de algoritmos de busca. Com uma boa heur\u00edstica, o algoritmo pode explorar apenas caminhos promissores, economizando tempo e recursos computacionais, ao passo que uma heur\u00edstica ruim pode levar o algoritmo a explorar caminhos irrelevantes, aumentando o custo computacional e potencialmente falhando em encontrar a solu\u00e7\u00e3o correta (ENGEL, 2011). Al\u00e9m disso, a escolha de uma boa fun\u00e7\u00e3o heur\u00edstica depende do problema em quest\u00e3o, e em alguns casos, ajustes podem ser necess\u00e1rios para melhorar a precis\u00e3o ou a efici\u00eancia do algoritmo.</p> <p>Em suma, as fun\u00e7\u00f5es heur\u00edsticas s\u00e3o indispens\u00e1veis em diversos dom\u00ednios da Intelig\u00eancia Artificial, como na navega\u00e7\u00e3o de rob\u00f4s, jogos de tabuleiro e otimiza\u00e7\u00e3o de processos. Elas permitem que algoritmos de busca informada, como o A*, se tornem mais eficientes e capazes de encontrar solu\u00e7\u00f5es \u00f3timas ou boas solu\u00e7\u00f5es de forma mais r\u00e1pida e precisa.</p>"},{"location":"modulo2/malha/","title":"Problemas de malha aberta e de malha fechada","text":"Problemas de Malha Aberta e de Malha Fechada  Os conceitos de malha aberta e malha fechada s\u00e3o amplamente utilizados em sistemas de controle e resolu\u00e7\u00e3o de problemas, sendo fundamentais para entender como diferentes sistemas reagem a vari\u00e1veis do ambiente e se adaptam ao longo do tempo (de acordo com a presen\u00e7a ou aus\u00eancia de realimenta\u00e7\u00e3o no processo de controle) (VanDoren, 2014).  A escolha entre esses dois tipos depende das necessidades espec\u00edficas de precis\u00e3o, efici\u00eancia e complexidade do sistema a ser automatizado (LMLOGIX, 2023).  Problemas de Malha Aberta  Nos sistemas de malha aberta, a a\u00e7\u00e3o de controle \u00e9 aplicada diretamente ao sistema sem levar em considera\u00e7\u00e3o o resultado da opera\u00e7\u00e3o. Isso significa que n\u00e3o h\u00e1 feedback cont\u00ednuo sobre o desempenho do sistema (VanDoren, 2014). Esses sistemas s\u00e3o caracterizados pela simplicidade de implementa\u00e7\u00e3o e menor custo inicial, pois n\u00e3o exigem sensores ou mecanismos de realimenta\u00e7\u00e3o complexos (LMLOGIX, 2023). No entanto, a falta de feedback cont\u00ednuo pode comprometer a precis\u00e3o e a flexibilidade em processos mais complexos (VanDoren, 2014).  Aplica\u00e7\u00f5es t\u00edpicas de sistemas de malha aberta incluem opera\u00e7\u00f5es previs\u00edveis, como o acionamento de motores e bombas, em que os comandos podem ser executados sem a necessidade de ajustes din\u00e2micos (LMLOGIX, 2023). Apesar de sua simplicidade, esses sistemas podem apresentar limita\u00e7\u00f5es em ambientes onde as condi\u00e7\u00f5es externas variam frequentemente, exigindo maior interven\u00e7\u00e3o manual para garantir a estabilidade do processo (VanDoren, 2014).  Caracter\u00edsticas principais <ol> <li>Execu\u00e7\u00e3o fixa: As a\u00e7\u00f5es s\u00e3o definidas previamente e n\u00e3o podem ser alteradas com base no desempenho real, tornando o sistema menos flex\u00edvel.</li> <li>Falta de adaptabilidade: Como n\u00e3o h\u00e1 realimenta\u00e7\u00e3o, o sistema n\u00e3o \u00e9 capaz de corrigir erros causados por varia\u00e7\u00f5es externas.</li> <li>Baixa complexidade: A aus\u00eancia de mecanismos de feedback reduz a complexidade e o custo do sistema.</li> <p> Um exemplo pr\u00e1tico de malha aberta \u00e9 um foguete sem controle remoto, que ao ser lan\u00e7ado, est\u00e1 programado para seguir uma rota espec\u00edfica, determinada por c\u00e1lculos feitos antes do lan\u00e7amento. No entanto, durante a viagem, fatores externos como o vento ou outras perturba\u00e7\u00f5es podem alterar essa trajet\u00f3ria. Sem a capacidade de ajustar sua rota, o foguete fica vulner\u00e1vel a desvios que podem comprometer o sucesso da miss\u00e3o. </p> Problemas de Malha Fechada  Por outro lado, os sistemas de malha fechada utilizam feedback cont\u00ednuo para monitorar e ajustar suas a\u00e7\u00f5es, visando manter uma condi\u00e7\u00e3o desejada de opera\u00e7\u00e3o (VanDoren, 2014). A presen\u00e7a de sensores e atuadores permite que o sistema corrija automaticamente qualquer desvio em rela\u00e7\u00e3o ao estado desejado, o que resulta em maior precis\u00e3o e confiabilidade (LMLOGIX, 2023).  Esses sistemas s\u00e3o amplamente utilizados em processos industriais complexos, como rob\u00f3tica e controle de temperatura em processos qu\u00edmicos, onde a precis\u00e3o \u00e9 fundamental (VanDoren, 2014). Contudo, a implementa\u00e7\u00e3o de sistemas de malha fechada pode ser mais onerosa devido ao custo adicional de componentes e \u00e0 maior complexidade do projeto (LMLOGIX, 2023).   Caracter\u00edsticas principais <ol> <li>Feedback cont\u00ednuo: O sistema coleta dados durante o processo, compara com a refer\u00eancia e faz ajustes autom\u00e1ticos.     <li>Adaptabilidade: Permite que o sistema se adapte a condi\u00e7\u00f5es externas vari\u00e1veis, aumentando sua robustez.     <li>Maior complexidade: Sistemas de malha fechada geralmente requerem sensores, processadores e atuadores, resultando em maior custo e complexidade.  Compara\u00e7\u00e3o e Escolha  A principal diferen\u00e7a entre os dois sistemas \u00e9 a presen\u00e7a de feedback. Enquanto os sistemas de malha aberta operam com comandos predefinidos, os de malha fechada ajustam continuamente suas opera\u00e7\u00f5es com base no feedback recebido (VanDoren, 2014). A escolha do tipo de sistema depende dos requisitos do processo: sistemas de malha fechada s\u00e3o prefer\u00edveis em processos que demandam alta precis\u00e3o e automa\u00e7\u00e3o, enquanto sistemas de malha aberta s\u00e3o ideais para opera\u00e7\u00f5es mais simples e previs\u00edveis (LMLOGIX, 2023).  Em alguns casos, pode ser vantajoso combinar as duas abordagens, utilizando controle em malha aberta para opera\u00e7\u00f5es b\u00e1sicas e controle em malha fechada para ajustes mais finos, garantindo assim maior efici\u00eancia e estabilidade (VanDoren, 2014).   Caracter\u00edstica Malha Aberta Malha Fechada Uso de feedback  N\u00e3o h\u00e1 feedback Feedback cont\u00ednuo Complexidade Simples  Mais complexa Robustez Sens\u00edvel a altera\u00e7\u00f5es Adapta-se a mudan\u00e7as Custo Geralmente menor Geralmente maior Exemplo Foguete com rota fixa Termostato ajustando a temperatura"},{"location":"modulo2/referencias/","title":"Refer\u00eancias","text":"Refer\u00eancias <p>LMLOGIX. (2023). Malha Fechada e Aberta: Entenda a Diferen\u00e7a. Dispon\u00edvel em: https://www.lmlogix.com.br/malha-fechada-e-aberta/. Acesso em: 03 jan. 2025.</p> <p>VanDoren, V. (2014). Open- vs. closed-loop control. Control Engineering. Dispon\u00edvel em: https://www.controleng.com/articles/open-vs-closed-loop-control/. Acesso em: 03 jan. 2025.</p> <p>BARROS, Leliane Nunes de. Agentes que resolvem problemas atrav\u00e9s de busca. Cap\u00edtulo 3, Parte I. Dispon\u00edvel em: : https://www.ime.usp.br/~leliane/IAcurso2006/slides/Aula3-buscageral-2006.pdf; leliane@ime.usp.br. 2010.</p> <p>NILSSON, Nils J. Principles of Artificial Intelligence Springer, 1980.</p> <p>CAMPUIM, Lucas. Busca Heur\u00edstica. Aula 5, 2020. Dispon\u00edvel em: https://www.cin.ufpe.br/~lfsc/cursos/introducaoainteligenciaartificial/IA-Aula5-BuscaHeuristica.pdf</p> <p>ENGEL, Paulo. M\u00e9todos de resolu\u00e7\u00e3o de problemas T\u00e9cnicas de busca. UFRGS. 2011. Dispon\u00edvel em: https://www.inf.ufrgs.br/~engel/data/media/file/inf01048/busca2.pdf</p> <p>RUSSELL, Stuart J.; NORVIG, Peter. Artificial Intelligence: A Modern Approach. 3. ed. Upper Saddle River: Prentice Hall, 2016.</p> <p>SOARES, Fabiano. FGA0221 - INTELIG\u00caNCIA ARTIFICIAL - 2024/2. Gama-DF: E-book. Dispon\u00edvel em:https://unbbr.sharepoint.com/:f:/s/FGA0221-INTELIGNCIAARTIFICIAL-2024_2/EpCk6sI26yRIvnd-rudKKsBMFZ8ByVdYNGsfmHumLYCNw?e=IQyhEu</p> <p>BARTZ-BEIELSTEIN, Thomas et al. Overview: Evolutionary Algorithms. Cologne University of Applied Sciences. 2014. Dispon\u00edvel em: https://www.researchgate.net/publication/261842296_Evolutionary_Algorithms</p>"},{"location":"modulo3/AtomicaFatorada/","title":"At\u00f4mica vs. Fatorada","text":"Considera\u00e7\u00f5es Iniciais <p>Ao iniciar o estudo sobre os Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs) e os conceitos relacionados \u00e0 representa\u00e7\u00e3o at\u00f4mica e fatorada, minhas expectativas giram em torno de compreender como essas abordagens podem ser aplicadas para modelar e resolver problemas de forma eficiente. O tema desperta grande interesse, pois combina conceitos de matem\u00e1tica, l\u00f3gica e computa\u00e7\u00e3o, \u00e1reas que considero essenciais para o avan\u00e7o da Intelig\u00eancia Artificial.  <p>Nas aulas da disciplina, aprendi que a representa\u00e7\u00e3o at\u00f4mica trata os estados de maneira indivis\u00edvel, enquanto a representa\u00e7\u00e3o fatorada permite decompor o problema em vari\u00e1veis e seus respectivos dom\u00ednios. Essa diferen\u00e7a foi marcante para entender como problemas complexos podem ser abordados com maior flexibilidade e escalabilidade. Tamb\u00e9m descobri que os CSPs s\u00e3o uma ferramenta poderosa para resolver problemas que envolvem restri\u00e7\u00f5es bem definidas, como planejamento de hor\u00e1rios e aloca\u00e7\u00e3o de recursos.  <p>Fiquei especialmente interessada no papel da consist\u00eancia em CSPs, pois ela parece ser uma estrat\u00e9gia essencial para reduzir o espa\u00e7o de busca e otimizar a solu\u00e7\u00e3o de problemas. Al\u00e9m disso, a aplica\u00e7\u00e3o de algoritmos cl\u00e1ssicos e avan\u00e7ados demonstra a relev\u00e2ncia pr\u00e1tica desse tema em \u00e1reas como log\u00edstica, jogos e sistemas de recomenda\u00e7\u00e3o.  <p>Minha expectativa \u00e9 aprofundar o entendimento sobre como essas teorias s\u00e3o implementadas na pr\u00e1tica, explorar algoritmos como backtracking e forward checking, e reconhecer os desafios associados \u00e0 modelagem de problemas complexos. Estou motivada a aprender como aplicar esses conhecimentos em cen\u00e1rios reais, utilizando ferramentas e frameworks da \u00e1rea para criar solu\u00e7\u00f5es robustas e eficientes.  Representa\u00e7\u00e3o At\u00f4mica vs. Fatorada <p>A distin\u00e7\u00e3o entre representa\u00e7\u00e3o at\u00f4mica e representa\u00e7\u00e3o fatorada desempenha um papel essencial no estudo e na resolu\u00e7\u00e3o de Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs, do ingl\u00eas Constraint Satisfaction Problems). Cada uma dessas formas de representa\u00e7\u00e3o possui caracter\u00edsticas espec\u00edficas que influenciam a abordagem de solu\u00e7\u00e3o e sua efici\u00eancia.</p> Representa\u00e7\u00e3o At\u00f4mica <p>A representa\u00e7\u00e3o at\u00f4mica trata cada estado ou configura\u00e7\u00e3o do problema como uma unidade indivis\u00edvel, sem divis\u00e3o em vari\u00e1veis menores. Essa abordagem considera todas as combina\u00e7\u00f5es poss\u00edveis de solu\u00e7\u00f5es como um \u00fanico conjunto agregado (SOARES, 2024). Embora simples em sua formula\u00e7\u00e3o, esse m\u00e9todo \u00e9 limitado por sua falta de escalabilidade e pela complexidade exponencial que surge \u00e0 medida que o tamanho do problema aumenta (Russell, 2016). </p> Exemplo: <p>No contexto de um jogo como o Sudoku, a representa\u00e7\u00e3o at\u00f4mica implicaria listar todas as configura\u00e7\u00f5es poss\u00edveis de preenchimento para a grade 9x9. Isso resulta em um n\u00famero exorbitante de possibilidades, tornando invi\u00e1vel o armazenamento e a manipula\u00e7\u00e3o de estados para resolver problemas de maior dimens\u00e3o.  Representa\u00e7\u00e3o Fatorada <p>Diferentemente da abordagem at\u00f4mica, a representa\u00e7\u00e3o fatorada decomp\u00f5e o problema em vari\u00e1veis individuais, cada uma com um dom\u00ednio de valores poss\u00edveis (Russell, 2016). Al\u00e9m disso, s\u00e3o especificadas restri\u00e7\u00f5es expl\u00edcitas que governam as rela\u00e7\u00f5es entre essas vari\u00e1veis (SOARES, 2024). Essa forma de representa\u00e7\u00e3o \u00e9 mais eficiente e frequentemente utilizada em Intelig\u00eancia Artificial para resolver problemas complexos.</p> <p>Exemplo: <p>Em um Sudoku, a representa\u00e7\u00e3o fatorada trata cada c\u00e9lula da grade como uma vari\u00e1vel separada. Cada vari\u00e1vel pode assumir um valor entre 1 e 9, e as restri\u00e7\u00f5es especificam que n\u00fameros n\u00e3o podem ser repetidos nas linhas, colunas e blocos. Essa estrutura\u00e7\u00e3o facilita a aplica\u00e7\u00e3o de algoritmos que trabalham diretamente na redu\u00e7\u00e3o dos espa\u00e7os de busca, como Backtracking e propaga\u00e7\u00e3o de restri\u00e7\u00f5es.   Vantagens da Representa\u00e7\u00e3o Fatorada <p>Escalabilidade: A decomposi\u00e7\u00e3o do problema em vari\u00e1veis e restri\u00e7\u00f5es permite lidar eficientemente com inst\u00e2ncias de grande escala, como Sudokus maiores ou CSPs complexos.  <p>Clareza e Flexibilidade: Modelar problemas fatoradamente torna mais simples ajustar ou expandir o modelo, adicionando ou modificando vari\u00e1veis e restri\u00e7\u00f5es sem reestruturar a representa\u00e7\u00e3o por completo.  <p>Efici\u00eancia: T\u00e9cnicas como a propaga\u00e7\u00e3o de restri\u00e7\u00f5es podem ser aplicadas para reduzir o espa\u00e7o de busca, resultando em solu\u00e7\u00f5es mais r\u00e1pidas e diretas (SOARES, 2024).  <p>A escolha entre representa\u00e7\u00e3o at\u00f4mica e fatorada depende do contexto e do tipo de problema. Entretanto, a abordagem fatorada \u00e9 amplamente preferida para resolver CSPs, devido \u00e0 sua capacidade de lidar com problemas mais complexos de forma escal\u00e1vel e eficiente. Como argumentado por Russel (2016), a representa\u00e7\u00e3o fatorada \u00e9 a base para solu\u00e7\u00f5es modernas em IA, permitindo a modelagem de problemas em termos de vari\u00e1veis e restri\u00e7\u00f5es interdependentes, promovendo resultados mais r\u00e1pidos e precisos."},{"location":"modulo3/algoritmos/","title":"Algoritmos","text":"Algoritmos - Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs)   Os algoritmos s\u00e3o fundamentais para a resolu\u00e7\u00e3o de problemas de satisfa\u00e7\u00e3o de restri\u00e7\u00f5es (CSPs), que envolvem a busca de valores para vari\u00e1veis sob um conjunto de restri\u00e7\u00f5es bem definidas. Esses problemas aparecem em diversas \u00e1reas, como planejamento de hor\u00e1rios, jogos e otimiza\u00e7\u00e3o. A seguir, abordaremos algumas abordagens cl\u00e1ssicas e avan\u00e7adas para resolver CSPs, com refer\u00eancias a autores consagrados na \u00e1rea.  Backtracking <p>O backtracking \u00e9 uma estrat\u00e9gia sistem\u00e1tica que explora todas as combina\u00e7\u00f5es poss\u00edveis de valores para vari\u00e1veis, retornando atr\u00e1s quando uma atribui\u00e7\u00e3o viola uma restri\u00e7\u00e3o. Segundo Russell e Norvig (2020), o algoritmo segue um fluxo simples de tentativa e erro, atribuindo valores a uma vari\u00e1vel por vez e retrocedendo quando necess\u00e1rio. Essa abordagem, embora intuitiva, \u00e9 limitada por sua inefici\u00eancia em problemas com muitos ramos, pois o n\u00famero de possibilidades cresce exponencialmente.  <p>Para melhorar o desempenho, t\u00e9cnicas complementares como a heur\u00edstica MRV (Minimum Remaining Values) s\u00e3o empregadas, priorizando a vari\u00e1vel com o menor n\u00famero de valores restantes. Essa estrat\u00e9gia reduz significativamente a \u00e1rvore de busca (RUSSELL; NORVIG, 2020).  Forward-Checking <p>O forward-checking \u00e9 uma extens\u00e3o do backtracking que elimina valores inconsistentes do dom\u00ednio das vari\u00e1veis ainda n\u00e3o atribu\u00eddas ap\u00f3s cada nova atribui\u00e7\u00e3o. Conforme Dechter (2003), essa t\u00e9cnica \u00e9 eficaz em detectar conflitos antecipadamente, reduzindo o espa\u00e7o de busca. Por exemplo, ao resolver um problema de agendamento, ao atribuir um hor\u00e1rio a um evento, o forward-checking remove hor\u00e1rios incompat\u00edveis para eventos relacionados.  Consist\u00eancia de Arco (AC-3) <p>O algoritmo AC-3 verifica iterativamente a consist\u00eancia entre pares de vari\u00e1veis conectadas por restri\u00e7\u00f5es. Como descrito por Poole e Mackworth (2010), ele analisa os arcos entre vari\u00e1veis \ud835\udc4b e \ud835\udc4c, removendo valores de \ud835\udc4b que n\u00e3o possuem suporte em \ud835\udc4c. Isso simplifica o problema, tornando-o mais trat\u00e1vel. Apesar de sua simplicidade e efici\u00eancia, o AC-3 pode ser limitado em cen\u00e1rios que exigem consist\u00eancia global. Nesses casos, algoritmos como o AC-4, com menor complexidade, podem ser mais adequados (DECHTER, 2003).  <p>Um exemplo pr\u00e1tico de CSP \u00e9 a resolu\u00e7\u00e3o de Sudoku. Nesse jogo, cada c\u00e9lula do tabuleiro \u00e9 tratada como uma vari\u00e1vel, e as restri\u00e7\u00f5es envolvem garantir que n\u00e3o haja valores repetidos em linhas, colunas e blocos. A aplica\u00e7\u00e3o do AC-3, combinada com t\u00e9cnicas como forward-checking e heur\u00edsticas para escolha de vari\u00e1veis, torna a resolu\u00e7\u00e3o eficiente (RUSSELL; NORVIG, 2020).  Melhorias em Backtracking <p>Para abordar a inefici\u00eancia do backtracking puro, combina-se a t\u00e9cnica com estrat\u00e9gias como:  <ul> <li>Heur\u00edsticas de Sele\u00e7\u00e3o de Vari\u00e1veis:  Prioriza\u00e7\u00e3o de vari\u00e1veis com mais restri\u00e7\u00f5es (heur\u00edstica de grau) ou com menos valores poss\u00edveis (MRV).</li> <li>Atribui\u00e7\u00e3o de Valores: Utilizar o valor menos restritivo para reduzir o impacto sobre vari\u00e1veis ainda n\u00e3o atribu\u00eddas.</li> <li>Infer\u00eancia: Uso de t\u00e9cnicas como o forward-checking e o AC-3 para reduzir os dom\u00ednios antes de explorar novas atribui\u00e7\u00f5es (DECHTER, 2003).</li> </ul> <p>Os algoritmos de CSP s\u00e3o essenciais para resolver problemas de restri\u00e7\u00f5es em diversos dom\u00ednios. Desde m\u00e9todos cl\u00e1ssicos, como o backtracking, at\u00e9 t\u00e9cnicas avan\u00e7adas, como o AC-3, a escolha da abordagem ideal depende da estrutura do problema e das restri\u00e7\u00f5es envolvidas. A efici\u00eancia alcan\u00e7ada por essas t\u00e9cnicas demonstra o potencial da intelig\u00eancia artificial em otimizar solu\u00e7\u00f5es complexas, tornando-a uma ferramenta indispens\u00e1vel na resolu\u00e7\u00e3o de CSPs."},{"location":"modulo3/consistencia/","title":"Consist\u00eancia","text":"Consist\u00eancia em Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es (CSP)   A consist\u00eancia em CSPs (Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es) \u00e9 fundamental para otimizar a busca por solu\u00e7\u00f5es v\u00e1lidas, reduzindo o espa\u00e7o de busca e garantindo que as atribui\u00e7\u00f5es de valores respeitem as restri\u00e7\u00f5es do problema. A seguir, exploraremos os conceitos de consist\u00eancia aplicados aos n\u00f3s, arcos, trajetos, k-consist\u00eancia e condi\u00e7\u00f5es globais.  Consist\u00eancia de N\u00f3s <p>Um n\u00f3 em um CSP representa uma vari\u00e1vel associada a um dom\u00ednio de valores. Diz-se que uma vari\u00e1vel \u00e9 n\u00f3-consistente se todos os valores em seu dom\u00ednio satisfazem suas restri\u00e7\u00f5es unit\u00e1rias (aquelas que envolvem apenas a pr\u00f3pria vari\u00e1vel). De acordo com Dechter (2003), a consist\u00eancia de n\u00f3s permite a elimina\u00e7\u00e3o de valores invi\u00e1veis de maneira isolada, antes de considerar intera\u00e7\u00f5es com outras vari\u00e1veis.</p> <p>Por exemplo, se a vari\u00e1vel X tem dom\u00ednio {1, 2, 3} e uma restri\u00e7\u00e3o que exige X &gt; 1, ent\u00e3o, ap\u00f3s a verifica\u00e7\u00e3o de consist\u00eancia, o dom\u00ednio ser\u00e1 reduzido para {2, 3}. Quando todos os n\u00f3s de um grafo s\u00e3o consistentes, o grafo \u00e9 considerado n\u00f3-consistente, facilitando a busca inicial por solu\u00e7\u00f5es ao remover valores obviamente inv\u00e1lidos.</p> Consist\u00eancia de Arco <p>A consist\u00eancia de arco verifica restri\u00e7\u00f5es bin\u00e1rias entre pares de vari\u00e1veis conectadas por um arco no grafo que representa o problema. Diz-se que duas vari\u00e1veis s\u00e3o arco-consistentes se, para cada valor em uma delas, existe pelo menos um valor correspondente na outra que satisfa\u00e7a a restri\u00e7\u00e3o entre elas (Russell &amp; Norvig, 2016).</p> <p>Por exemplo, considere as vari\u00e1veis X e Y com restri\u00e7\u00e3o \\(Y = X^2\\). Se o dom\u00ednio de X for {0, 1, 2, 3}, a consist\u00eancia de arco exigir\u00e1 que o dom\u00ednio de Y seja reduzido para {0, 1, 4, 9}, garantindo que todos os valores em X tenham correspondentes v\u00e1lidos em Y.</p> <p>Algoritmos como o AC-3 s\u00e3o amplamente utilizados para garantir a consist\u00eancia de arco, eliminando valores incompat\u00edveis e reduzindo o espa\u00e7o de busca (Dechter, 2003).</p> Consist\u00eancia de Trajeto <p>A consist\u00eancia de trajeto vai al\u00e9m de pares de vari\u00e1veis, estendendo a an\u00e1lise para trios ou grupos maiores. Tr\u00eas vari\u00e1veis X, Y, Z s\u00e3o consideradas trajeto-consistentes se, para qualquer valor consistente entre X e Y, e entre X e Z, h\u00e1 pelo menos um valor em Z que mant\u00e9m a consist\u00eancia (Poole &amp; Mackworth, 2017).</p> <p>Por exemplo, considere as restri\u00e7\u00f5es \\(X + Y = 10, X + Z = 15\\) e os dom\u00ednios \\(X = \\{5, 10\\}\\), \\(Y = \\{5, 10\\}\\), \\(Z = \\{5, 10\\}\\). A consist\u00eancia de trajeto verificar\u00e1 que, para \\(X = 5\\), \\(Y = 5\\) satisfaz \\(X + Y\\), mas requer \\(Z = 10\\) para satisfazer \\(X + Z\\). A consist\u00eancia de trajeto permite reduzir ainda mais os dom\u00ednios, considerando implica\u00e7\u00f5es em m\u00faltiplas vari\u00e1veis.</p> Consist\u00eancia K <p>A k-consist\u00eancia \u00e9 uma generaliza\u00e7\u00e3o da consist\u00eancia de trajeto para conjuntos maiores de vari\u00e1veis. Um CSP \u00e9 k-consistente se, para qualquer atribui\u00e7\u00e3o consistente de k - 1 vari\u00e1veis, existe uma atribui\u00e7\u00e3o consistente para a k-\u00e9sima vari\u00e1vel (Fr\u00fchwirth, 1998). Al\u00e9m disso, um CSP \u00e9 fortemente k-consistente se for k-consistente para todos os valores de k at\u00e9 o n\u00famero total de vari\u00e1veis.</p> <p>Por exemplo, em um problema com tr\u00eas vari\u00e1veis X, Y, Z, a 3-consist\u00eancia garante que, se X = 1 e Y = 2 s\u00e3o consistentes, ser\u00e1 poss\u00edvel atribuir um valor consistente a Z.</p> Consist\u00eancia Global <p>A consist\u00eancia global, como destacado por Russell e Norvig (2016), considera todas as restri\u00e7\u00f5es do problema simultaneamente. Um grafo \u00e9 globalmente consistente se for k-consistente para todo k, garantindo que qualquer subconjunto de vari\u00e1veis possa ser atribu\u00eddo de maneira consistente sem violar as restri\u00e7\u00f5es.</p> <p>A consist\u00eancia global pode ser alcan\u00e7ada por t\u00e9cnicas como propaga\u00e7\u00e3o de limites, que identifica e remove valores inconsistentes de maneira eficiente, evitando a verifica\u00e7\u00e3o exaustiva de todas as combina\u00e7\u00f5es poss\u00edveis (Poole &amp; Mackworth, 2017).</p>"},{"location":"modulo3/implementacao/","title":"Implementacao","text":"Implementa\u00e7\u00e3o dos Algoritmos <p>Este exemplo utiliza um algoritmo gen\u00e9tico para resolver o problema de agendamento de aluguel de quadras de pickleball, onde o objetivo \u00e9 alocar quadras e hor\u00e1rios para diferentes grupos de jogadores, garantindo que:</p> <ul> <li>Nenhuma quadra seja usada por mais de um grupo ao mesmo tempo.</li> <li>Cada grupo respeite as restri\u00e7\u00f5es de disponibilidade das quadras e dos jogadores.</li> </ul> Defini\u00e7\u00e3o do Problema <p>No problema, temos as seguintes vari\u00e1veis:</p> <ul> <li>Quadras: Quadra 1, Quadra 2, Quadra 3</li> <li>Hor\u00e1rios: 9:00-10:00, 10:00-11:00, 11:00-12:00</li> <li>Grupos: Grupo A, Grupo B, Grupo C, Grupo D</li> </ul> <p>Os grupos t\u00eam restri\u00e7\u00f5es sobre quais quadras e hor\u00e1rios est\u00e3o dispon\u00edveis. A solu\u00e7\u00e3o busca alocar cada grupo em uma quadra e hor\u00e1rio dispon\u00edveis, respeitando as restri\u00e7\u00f5es.</p> Exemplo de Execu\u00e7\u00e3o <p>Ap\u00f3s executar o algoritmo gen\u00e9tico, a solu\u00e7\u00e3o final \u00e9 apresentada, onde cada grupo est\u00e1 alocado em uma quadra e hor\u00e1rio v\u00e1lidos:</p> <pre>\n\nGrupo A: Quadra 1 \u00e0s 9:00-10:00\nGrupo B: Quadra 2 \u00e0s 10:00-11:00\nGrupo C: Quadra 3 \u00e0s 11:00-12:00\nGrupo D: Quadra 1 \u00e0s 10:00-11:00\n</pre> <p>O algoritmo gen\u00e9tico continua iterando at\u00e9 que uma solu\u00e7\u00e3o v\u00e1lida seja encontrada ou o n\u00famero m\u00e1ximo de gera\u00e7\u00f5es seja alcan\u00e7ado.</p> <pre><code>import random\n\n# Par\u00e2metros do Algoritmo Gen\u00e9tico\nPOPULATION_SIZE = 500\nMUTATION_RATE = 0.1\nGENERATIONS = 1000\n\n# Problema de Agendamento de Quadras\nAVAILABILITY = {\n    \"Quadra 1\": [\"9:00-10:00\", \"10:00-11:00\", \"11:00-12:00\"],\n    \"Quadra 2\": [\"9:00-10:00\", \"10:00-11:00\", \"11:00-12:00\"],\n    \"Quadra 3\": [\"9:00-10:00\", \"10:00-11:00\", \"11:00-12:00\"]\n}\n\nGROUPS = [\"Grupo A\", \"Grupo B\", \"Grupo C\", \"Grupo D\"]\n\n# Fun\u00e7\u00e3o para criar uma solu\u00e7\u00e3o inicial aleat\u00f3ria\ndef create_individual():\n    individual = []\n    for group in GROUPS:\n        quadra = random.choice(list(AVAILABILITY.keys()))\n        horario = random.choice(AVAILABILITY[quadra])\n        individual.append((group, quadra, horario))\n    return individual\n\n# Fun\u00e7\u00e3o de avalia\u00e7\u00e3o (fitness)\ndef fitness(individual):\n    score = 0\n    # Penaliza se duas reuni\u00f5es ocorrerem no mesmo hor\u00e1rio em uma mesma quadra\n    for i, (group1, quadra1, horario1) in enumerate(individual):\n        for j, (group2, quadra2, horario2) in enumerate(individual):\n            if i != j and quadra1 == quadra2 and horario1 == horario2:\n                score -= 1\n    return score\n\n# Fun\u00e7\u00e3o de cruzamento\ndef crossover(parent1, parent2):\n    point = random.randint(1, len(parent1) - 1)\n    child = parent1[:point] + parent2[point:]\n    return child\n\n# Fun\u00e7\u00e3o de muta\u00e7\u00e3o\ndef mutate(individual):\n    if random.random() &lt; MUTATION_RATE:\n        idx = random.randint(0, len(individual) - 1)\n        group, quadra, horario = individual[idx]\n        new_quadra = random.choice(list(AVAILABILITY.keys()))\n        new_horario = random.choice(AVAILABILITY[new_quadra])\n        individual[idx] = (group, new_quadra, new_horario)\n\n# Algoritmo Gen\u00e9tico Principal\ndef genetic_algorithm():\n    population = [create_individual() for _ in range(POPULATION_SIZE)]\n    for generation in range(GENERATIONS):\n        population = sorted(population, key=fitness, reverse=True)\n        if fitness(population[0]) == 0:  # Nenhum conflito\n            print(f\"Solu\u00e7\u00e3o encontrada na gera\u00e7\u00e3o {generation}\")\n            return population[0]\n        next_generation = population[:POPULATION_SIZE // 2]\n        for i in range(POPULATION_SIZE // 2):\n            parent1, parent2 = random.sample(next_generation, 2)\n            child = crossover(parent1, parent2)\n            mutate(child)\n            next_generation.append(child)\n        population = next_generation\n    print(\"Nenhuma solu\u00e7\u00e3o encontrada\")\n    return None\n\n# Resolver o problema de agendamento\nsolution = genetic_algorithm()\nif solution:\n    for group, quadra, horario in solution:\n        print(f\"{group}: {quadra} \u00e0s {horario}\")\n</code></pre> Explica\u00e7\u00e3o do Algoritmo <p>O algoritmo gen\u00e9tico \u00e9 utilizado para encontrar uma solu\u00e7\u00e3o \u00f3tima para o problema de agendamento. Ele funciona da seguinte forma:</p> <p>1. Cria\u00e7\u00e3o Inicial: A fun\u00e7\u00e3o create_individual() cria uma solu\u00e7\u00e3o inicial aleat\u00f3ria, onde cada grupo \u00e9 atribu\u00eddo a uma quadra e hor\u00e1rio dispon\u00edveis.  <p>2. Avalia\u00e7\u00e3o (Fitness): A fun\u00e7\u00e3o fitness() calcula a qualidade de uma solu\u00e7\u00e3o, penalizando solu\u00e7\u00f5es que causam conflitos, ou seja, quando mais de um grupo tenta usar a mesma quadra no mesmo hor\u00e1rio.</p> <p>3. Cruzamento: O cruzamento ocorre na fun\u00e7\u00e3o crossover(), onde duas solu\u00e7\u00f5es \"pais\" s\u00e3o combinadas para gerar uma nova solu\u00e7\u00e3o \"filha\".</p> <p>4. Muta\u00e7\u00e3o: A fun\u00e7\u00e3o mutate() faz altera\u00e7\u00f5es aleat\u00f3rias em uma solu\u00e7\u00e3o, trocando a quadra ou o hor\u00e1rio de uma reuni\u00e3o, a fim de explorar novas solu\u00e7\u00f5es.</p> <p>5. Itera\u00e7\u00f5es: O algoritmo gen\u00e9tico \u00e9 executado na fun\u00e7\u00e3o genetic_algorithm(), que gera uma popula\u00e7\u00e3o inicial de solu\u00e7\u00f5es e aplica o processo de cruzamento e muta\u00e7\u00e3o por v\u00e1rias gera\u00e7\u00f5es at\u00e9 que uma solu\u00e7\u00e3o v\u00e1lida seja encontrada.</p>"},{"location":"modulo3/problemas/","title":"Estruturas de Problemas","text":"Estrutura de Problemas em CSP <p>Os Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (Constraint Satisfaction Problems - CSPs) s\u00e3o amplamente utilizados em Intelig\u00eancia Artificial para modelar situa\u00e7\u00f5es que exigem a satisfa\u00e7\u00e3o de condi\u00e7\u00f5es espec\u00edficas. A estrutura de um CSP \u00e9 composta por vari\u00e1veis, dom\u00ednios e restri\u00e7\u00f5es, elementos fundamentais para o entendimento e a resolu\u00e7\u00e3o desses problemas de maneira eficiente (RUSSELL; NORVIG, 2021).  Representa\u00e7\u00e3o Gr\u00e1fica de CSP <p>Um CSP pode ser representado como um grafo onde:  <ol> <li>N\u00f3s (vari\u00e1veis): Cada vari\u00e1vel do problema \u00e9 representada como um n\u00f3. O conjunto de valores poss\u00edveis que cada vari\u00e1vel pode assumir \u00e9 chamado de dom\u00ednio.</li> <li>Arestas (restri\u00e7\u00f5es):  As arestas conectam vari\u00e1veis relacionadas por restri\u00e7\u00f5es. Cada aresta representa uma condi\u00e7\u00e3o que deve ser satisfeita entre as vari\u00e1veis conectadas.</li> </ol>  Por exemplo, no problema de colorir um grafo, onde \u00e9 necess\u00e1rio atribuir cores aos v\u00e9rtices de forma que v\u00e9rtices adjacentes n\u00e3o compartilhem a mesma cor, os n\u00f3s correspondem aos v\u00e9rtices do grafo, e as arestas representam a restri\u00e7\u00e3o de que duas vari\u00e1veis adjacentes n\u00e3o podem ter valores iguais.  Estruturas de Grafos: Esparsos vs. Densos <p>A complexidade de um CSP \u00e9 influenciada pela densidade do grafo que o representa: <ol> <li>Grafos esparsos:: Possuem poucas arestas em rela\u00e7\u00e3o ao n\u00famero de n\u00f3s, indicando menos intera\u00e7\u00f5es entre as vari\u00e1veis. Esses problemas geralmente s\u00e3o mais f\u00e1ceis de resolver, pois o espa\u00e7o de busca \u00e9 menor.</li> <li>Grafos densos: Possuem muitas arestas, representando numerosas restri\u00e7\u00f5es entre as vari\u00e1veis. A solu\u00e7\u00e3o de CSPs com grafos densos pode ser desafiadora devido \u00e0 maior interdepend\u00eancia entre as vari\u00e1veis (Dechter, 2003).</li> </ol> Estrat\u00e9gias de Decomposi\u00e7\u00e3o <p>A decomposi\u00e7\u00e3o de CSPs em subproblemas \u00e9 uma t\u00e9cnica que busca reduzir a complexidade computacional:  <ol> <li>Identifica\u00e7\u00e3o de Componentes Conectados:: Ao dividir o grafo em componentes independentes, cada subgrafo pode ser resolvido separadamente, economizando recursos computacionais (Fr\u00fchwirth, 1998).</li> <li>Decomposi\u00e7\u00e3o em \u00c1rvore:Transformar o grafo em uma estrutura em \u00e1rvore \u00e9 particularmente \u00fatil. Para isso, vari\u00e1veis podem ser organizadas em um formato hier\u00e1rquico, onde cada n\u00f3 pai conecta-se a seus filhos por restri\u00e7\u00f5es. Quando o grafo \u00e9 arco-consistente, \u00e9 garantido que cada valor atribu\u00eddo a uma vari\u00e1vel ter\u00e1 suporte v\u00e1lido nas vari\u00e1veis relacionadas.</li> </ol> Consist\u00eancia Local <p>A aplica\u00e7\u00e3o de t\u00e9cnicas de consist\u00eancia local, como a consist\u00eancia de arco e de caminho, reduz o espa\u00e7o de busca ao eliminar valores inconsistentes antes da busca. Isso \u00e9 feito verificando se cada valor no dom\u00ednio de uma vari\u00e1vel est\u00e1 em conformidade com as restri\u00e7\u00f5es que a conectam a outras vari\u00e1veis (Poole &amp; Mackworth, 2010).  Para CSPs mais complexos, heur\u00edsticas s\u00e3o empregadas para guiar a busca por solu\u00e7\u00f5es:  <ol> <li>Heur\u00edstica do M\u00ednimo Conflito (Min-Conflicts): Seleciona valores que minimizam o n\u00famero de restri\u00e7\u00f5es violadas. Essa abordagem \u00e9 eficaz em problemas onde as solu\u00e7\u00f5es v\u00e1lidas est\u00e3o distribu\u00eddas de forma densa no espa\u00e7o de busca (Russell &amp; Norvig, 2016). </li> </ol> <p>CSPs t\u00eam aplica\u00e7\u00f5es em \u00e1reas como jogos, design de sistemas e planejamento. A modelagem precisa e a an\u00e1lise estrutural s\u00e3o fundamentais para o sucesso. Vari\u00e1veis, dom\u00ednios, restri\u00e7\u00f5es e objetivos devem ser bem definidos para garantir a viabilidade das solu\u00e7\u00f5es. Conforme Negnevitsky (2005), o uso de representa\u00e7\u00f5es gr\u00e1ficas e t\u00e9cnicas de modelagem adaptativa permite lidar com problemas din\u00e2micos, aumentando a efici\u00eancia e a precis\u00e3o das solu\u00e7\u00f5es.  <p>Em resumo, a estrutura de CSPs oferece uma base s\u00f3lida para o desenvolvimento de algoritmos eficazes, que s\u00e3o essenciais para resolver desafios reais que demandam a satisfa\u00e7\u00e3o de condi\u00e7\u00f5es espec\u00edficas. A explora\u00e7\u00e3o de suas propriedades gr\u00e1ficas, a aplica\u00e7\u00e3o de consist\u00eancia local e o uso de heur\u00edsticas desempenham pap\u00e9is centrais na redu\u00e7\u00e3o da complexidade e na obten\u00e7\u00e3o de solu\u00e7\u00f5es eficientes."},{"location":"modulo3/referencias/","title":"Refer\u00eancias","text":"Refer\u00eancias <p>USSELL, Stuart J.; NORVIG, Peter. Artificial Intelligence: A Modern Approach. 3. ed. Upper Saddle River: Prentice Hall, 2016.</p> <p>SOARES, Fabiano. FGA0221 - INTELIG\u00caNCIA ARTIFICIAL - 2024/2. Gama-DF: E-book.</p> <p>DECHTER, Rina. Constraint Processing. San Francisco: Morgan Kaufmann, 2003.</p> <p>FR\u00dcHWIRTH, Thom. Essentials of Constraint Programming. Cambridge: Springer, 1998.</p> <p>KRUSE, Rudolf et al. Computational Intelligence: A Methodological Introduction. Cham: Springer, 2016.</p> <p>NEGNEVITSKY, Michael. Artificial Intelligence: A Guide to Intelligent Systems. Harlow: Pearson Education, 2011.</p> <p>POOLE, David; MACKWORTH, Alan. Artificial Intelligence: Foundations of Computational Agents. Cambridge: Cambridge University Press, 2017.</p> <p>SCHIEX, Thomas; FARGIER, H\u00e9l\u00e8ne; VERFAILLIE, G\u00e9rard. Valued Constraint Satisfaction Problems: Hard and Easy Problems. Toulouse: Institut National de la Recherche Agronomique, 1995.</p>"},{"location":"modulo3/restricoes/","title":"Tipos de Restri\u00e7\u00f5es","text":"Tipos de Restri\u00e7\u00f5es em Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es   Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es (CSPs) s\u00e3o amplamente utilizados na Intelig\u00eancia Artificial para modelar e resolver problemas complexos que envolvem a atribui\u00e7\u00e3o de valores a vari\u00e1veis dentro de um conjunto de restri\u00e7\u00f5es. Essas restri\u00e7\u00f5es definem as condi\u00e7\u00f5es que precisam ser atendidas para que uma solu\u00e7\u00e3o seja v\u00e1lida. Segundo Dechter (2003), as restri\u00e7\u00f5es podem ser categorizadas em diferentes tipos, de acordo com o n\u00famero de vari\u00e1veis envolvidas e a natureza da condi\u00e7\u00e3o que elas imp\u00f5em. As principais categorias incluem restri\u00e7\u00f5es un\u00e1rias, bin\u00e1rias e n-\u00e1rias.  Restri\u00e7\u00f5es Un\u00e1rias <p>As restri\u00e7\u00f5es un\u00e1rias envolvem uma \u00fanica vari\u00e1vel e definem condi\u00e7\u00f5es diretamente relacionadas a ela. Elas s\u00e3o \u00fateis para reduzir o espa\u00e7o de busca ao eliminar valores que n\u00e3o atendem aos crit\u00e9rios definidos.  Exemplo: <p>Considere um sistema de inscri\u00e7\u00e3o em cursos onde \u00e9 necess\u00e1rio que os alunos tenham pelo menos 18 anos. Nesse caso, a vari\u00e1vel \"idade do aluno\" est\u00e1 sujeita a uma restri\u00e7\u00e3o un\u00e1ria, permitindo apenas valores iguais ou superiores a 18.  <p>De acordo com Russell e Norvig (2020), essas restri\u00e7\u00f5es s\u00e3o frequentemente aplicadas como uma etapa inicial de poda no espa\u00e7o de busca.  Restri\u00e7\u00f5es Bin\u00e1rias <p>As restri\u00e7\u00f5es bin\u00e1rias relacionam duas vari\u00e1veis e imp\u00f5em condi\u00e7\u00f5es entre os valores que elas podem assumir. Esse tipo de restri\u00e7\u00e3o \u00e9 comum em problemas como agendamento e aloca\u00e7\u00e3o de recursos.  Exemplo: <p>Em um problema de escalonamento, \"o funcion\u00e1rio A n\u00e3o pode trabalhar no mesmo turno que o funcion\u00e1rio B\". Essa restri\u00e7\u00e3o bin\u00e1ria aplica-se \u00e0s vari\u00e1veis \"turno do funcion\u00e1rio A\" e \"turno do funcion\u00e1rio B\", exigindo que seus valores sejam diferentes.  <p>Segundo Fr\u00fchwirth (1998), restri\u00e7\u00f5es bin\u00e1rias s\u00e3o frequentemente usadas em representa\u00e7\u00f5es gr\u00e1ficas, onde as vari\u00e1veis s\u00e3o representadas como n\u00f3s e as restri\u00e7\u00f5es como arestas.  Restri\u00e7\u00f5es N-\u00e1rias <p>Restri\u00e7\u00f5es n-\u00e1rias envolvem tr\u00eas ou mais vari\u00e1veis, aumentando significativamente a complexidade do problema. Elas s\u00e3o essenciais para modelar intera\u00e7\u00f5es complexas entre diferentes elementos.  Exemplo: <p>No caso de tr\u00eas amigos que desejam assistir a um filme, uma restri\u00e7\u00e3o n-\u00e1ria poderia ser: \"Ana, Beatriz e Carlos n\u00e3o podem ir ao cinema no mesmo hor\u00e1rio\". Aqui, as vari\u00e1veis \"hor\u00e1rio de Ana\", \"hor\u00e1rio de Beatriz\" e \"hor\u00e1rio de Carlos\" devem ser atribu\u00eddas de forma que pelo menos uma delas tenha um valor diferente das demais.  <p>Como destacado por Negnevitsky (2005), a representa\u00e7\u00e3o expl\u00edcita de restri\u00e7\u00f5es n-\u00e1rias pode ser desafiadora, mas em muitos casos \u00e9 poss\u00edvel reduzi-las a combina\u00e7\u00f5es de restri\u00e7\u00f5es bin\u00e1rias.  Restri\u00e7\u00f5es Globais <p>Restri\u00e7\u00f5es globais s\u00e3o aplicadas a conjuntos maiores de vari\u00e1veis e ajudam a simplificar a modelagem de problemas que possuem condi\u00e7\u00f5es repetitivas ou complexas.  Exemplo: <p>O problema do Sudoku exemplifica restri\u00e7\u00f5es globais, pois exige que cada n\u00famero apare\u00e7a apenas uma vez em cada linha, coluna e bloco. Conforme discutido por Dechter (2003), restri\u00e7\u00f5es globais como essa s\u00e3o \u00fateis para reduzir o espa\u00e7o de busca e melhorar a efici\u00eancia dos algoritmos de resolu\u00e7\u00e3o.  Natureza das Restri\u00e7\u00f5es <p>Al\u00e9m da classifica\u00e7\u00e3o baseada no n\u00famero de vari\u00e1veis, as restri\u00e7\u00f5es podem ser caracterizadas pela sua natureza:</p> <ul> <li>Necess\u00e1rias: Devem ser obrigatoriamente satisfeitas para que uma solu\u00e7\u00e3o seja v\u00e1lida.</li> <li>Preferenciais: Indicam condi\u00e7\u00f5es desej\u00e1veis, mas que n\u00e3o necessariamente invalidam uma solu\u00e7\u00e3o caso n\u00e3o sejam atendidas (RUSSELL; NORVIG, 2020).</li> </ul> <p>Dechter (2003) tamb\u00e9m destaca que condi\u00e7\u00f5es de ordem, igualdade, desigualdade e soma s\u00e3o amplamente aplicadas para representar diferentes tipos de restri\u00e7\u00f5es. Por exemplo, em problemas de agendamento, restri\u00e7\u00f5es de ordem s\u00e3o usadas para garantir que uma tarefa seja conclu\u00edda antes que outra possa come\u00e7ar.</p> <p>A escolha e a aplica\u00e7\u00e3o adequadas de restri\u00e7\u00f5es s\u00e3o cruciais para representar as condi\u00e7\u00f5es inerentes a um problema e alcan\u00e7ar solu\u00e7\u00f5es eficientes. As restri\u00e7\u00f5es un\u00e1rias, bin\u00e1rias e n-\u00e1rias s\u00e3o fundamentais na modelagem de CSPs, cada uma desempenhando um papel espec\u00edfico. Al\u00e9m disso, a introdu\u00e7\u00e3o de restri\u00e7\u00f5es globais e a considera\u00e7\u00e3o de condi\u00e7\u00f5es necess\u00e1rias e preferenciais permitem a cria\u00e7\u00e3o de modelos robustos e otimizados, como enfatizado por Fr\u00fchwirth (1998) e Negnevitsky (2005). O estudo detalhado dessas restri\u00e7\u00f5es contribui significativamente para o avan\u00e7o das t\u00e9cnicas de resolu\u00e7\u00e3o em Intelig\u00eancia Artificial."},{"location":"modulo3/satisfacao/","title":"Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es","text":"Definindo Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es (CSP)   Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es (do ingl\u00eas, Constraint Satisfaction Problems - CSPs) s\u00e3o um tipo de problema em que se busca atribuir valores a um conjunto de vari\u00e1veis de modo que todas as restri\u00e7\u00f5es especificadas sejam atendidas simultaneamente. Esse modelo de problema \u00e9 amplamente estudado no campo da Intelig\u00eancia Artificial devido \u00e0 sua flexibilidade para representar e resolver desafios complexos em diversos dom\u00ednios (DECHTER, 2003).  Componentes Fundamentais dos CSPs <p>Um CSP \u00e9 caracterizado por tr\u00eas elementos principais, conforme descrito por Schiex, Fargier e Verfaillie (1995):</p> <ol> <li>Vari\u00e1veis (X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>n</sub>): Conjunto de vari\u00e1veis cujos valores precisam ser determinados.</li> <li>Dom\u00ednios (D<sub>1</sub>, D<sub>2</sub>, ..., D<sub>n</sub>): Conjunto de valores poss\u00edveis que cada vari\u00e1vel pode assumir. Por exemplo, em um problema de aloca\u00e7\u00e3o de hor\u00e1rios escolares, os dom\u00ednios seriam os hor\u00e1rios dispon\u00edveis.</li> <li>Restri\u00e7\u00f5es (C): Regras ou condi\u00e7\u00f5es que limitam as combina\u00e7\u00f5es permitidas de valores atribu\u00eddos \u00e0s vari\u00e1veis. Essas restri\u00e7\u00f5es podem ser definidas como regras bin\u00e1rias (entre duas vari\u00e1veis) ou n-\u00e1rias (envolvendo mais de duas vari\u00e1veis).</li> </ol> <p>A resolu\u00e7\u00e3o de um CSP consiste em encontrar uma atribui\u00e7\u00e3o de valores para as vari\u00e1veis que satisfa\u00e7a todas as restri\u00e7\u00f5es definidas. Quando todas as vari\u00e1veis possuem valores atribu\u00eddos e nenhuma restri\u00e7\u00e3o \u00e9 violada, diz-se que a atribui\u00e7\u00e3o \u00e9 completa e consistente (RUSSELL; NORVIG, 2020).</p> Representa\u00e7\u00e3o Gr\u00e1fica de CSPs  CSPs podem ser representados como grafos, onde os n\u00f3s correspondem \u00e0s vari\u00e1veis e as arestas \u00e0s restri\u00e7\u00f5es. Essa representa\u00e7\u00e3o visual facilita a an\u00e1lise e a aplica\u00e7\u00e3o de algoritmos para resolver o problema (POOLE; MACKWORTH, 2017).  <ol> <li>Sudoku: Cada c\u00e9lula do tabuleiro \u00e9 uma vari\u00e1vel, com valores poss\u00edveis entre 1 e 9. As restri\u00e7\u00f5es garantem que n\u00e3o haja repeti\u00e7\u00e3o de n\u00fameros em linhas, colunas ou subgrades (NEGNEVITSKY, 2011).</li> <li>Agendamento de Exames: As vari\u00e1veis representam os exames, os dom\u00ednios s\u00e3o os hor\u00e1rios dispon\u00edveis e as restri\u00e7\u00f5es asseguram que exames com alunos em comum n\u00e3o sejam alocados simultaneamente (KRUSE et al., 2016).</li> <li>Colora\u00e7\u00e3o de Grafos: Cada n\u00f3 do grafo representa uma regi\u00e3o, e as restri\u00e7\u00f5es garantem que regi\u00f5es adjacentes n\u00e3o tenham a mesma cor. Esse problema \u00e9 usado em aplica\u00e7\u00f5es como a aloca\u00e7\u00e3o de frequ\u00eancias em redes de telecomunica\u00e7\u00f5es (SCHIEX; FARGIER; VERFAILLIE, 1995).</li> </ol>  Os Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es representam uma classe poderosa de problemas que podem modelar situa\u00e7\u00f5es complexas de maneira estruturada. Sua ampla aplicabilidade em \u00e1reas como otimiza\u00e7\u00e3o de recursos, agendamento e design de redes destaca sua import\u00e2ncia no avan\u00e7o da Intelig\u00eancia Artificial. Conforme Dechter (2003) ressalta, o desenvolvimento cont\u00ednuo de algoritmos eficientes para CSPs \u00e9 essencial para lidar com os desafios crescentes do mundo moderno.  Algoritmos para Resolu\u00e7\u00e3o de CSPs <p>Os CSPs podem ser resolvidos utilizando diversas abordagens, como:</p> <ol> <li>Busca Backtracking: Realiza atribui\u00e7\u00f5es incrementais, verificando a consist\u00eancia local a cada passo. Pode ser aprimorada com heur\u00edsticas como Minimum Remaining Values (MRV) e t\u00e9cnicas como Forward Checking (DECHTER, 2003).</li> <li>Consist\u00eancia de Arcos (AC-3): Garante que todos os valores no dom\u00ednio de uma vari\u00e1vel s\u00e3o consistentes com as restri\u00e7\u00f5es envolvendo vari\u00e1veis conectadas. \u00c9 amplamente utilizado devido \u00e0 sua simplicidade (FR\u00dcHWIRTH, 1998).</li> <li>Busca Local: Adequada para problemas em larga escala, utiliza m\u00e9todos como Hill Climbing e Simulated Annealing para explorar solu\u00e7\u00f5es aproximadas em espa\u00e7os de busca extensos (KRUSE et al., 2016).</li> </ol> <p>Os Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es representam uma classe poderosa de problemas que podem modelar situa\u00e7\u00f5es complexas de maneira estruturada. Sua ampla aplicabilidade em \u00e1reas como otimiza\u00e7\u00e3o de recursos, agendamento e design de redes destaca sua import\u00e2ncia no avan\u00e7o da Intelig\u00eancia Artificial. Conforme Dechter (2003) ressalta, o desenvolvimento cont\u00ednuo de algoritmos eficientes para CSPs \u00e9 essencial para lidar com os desafios crescentes do mundo moderno."},{"location":"modulo4/agente-conhecimento/","title":"Agente baseado em conhecimento","text":"Considera\u00e7\u00f5es Iniciais <p>Ao iniciar o estudo sobre agentes baseados em conhecimento, minhas expectativas s\u00e3o compreender como esses sistemas utilizam bases de conhecimento e processos de infer\u00eancia l\u00f3gica para tomar decis\u00f5es inteligentes. Estou particularmente interessada em como essas tecnologias podem ser aplicadas para resolver problemas reais de forma eficiente e adaptativa, especialmente em contextos onde h\u00e1 incerteza ou informa\u00e7\u00f5es incompletas.  <p>Pelas aulas da mat\u00e9ria, entendi que agentes baseados em conhecimento funcionam como sistemas que armazenam informa\u00e7\u00f5es em uma estrutura formal e utilizam regras l\u00f3gicas para raciocinar e inferir novas conclus\u00f5es. Conceitos como l\u00f3gica proposicional, sintaxe, sem\u00e2ntica e infer\u00eancia foram apresentados como fundamentos essenciais para a implementa\u00e7\u00e3o desses agentes. Tamb\u00e9m foi esclarecido como a l\u00f3gica formal \u00e9 aplicada para garantir que as decis\u00f5es sejam racionais e consistentes.  <p>Atrav\u00e9s de exemplos como o mundo do Wumpus, percebi que o uso de regras l\u00f3gicas permite que um agente analise o ambiente, preveja consequ\u00eancias de a\u00e7\u00f5es e escolha os melhores caminhos para alcan\u00e7ar objetivos. Esse aprendizado despertou minha curiosidade sobre as limita\u00e7\u00f5es e desafios, como a escalabilidade do sistema e a necessidade de representa\u00e7\u00e3o precisa do conhecimento.  <p>Espero aprofundar meu entendimento sobre como projetar e implementar agentes baseados em conhecimento, explorando diferentes m\u00e9todos de infer\u00eancia e suas aplica\u00e7\u00f5es pr\u00e1ticas. Meu objetivo \u00e9 n\u00e3o apenas entender os conceitos te\u00f3ricos, mas tamb\u00e9m desenvolver habilidades para aplic\u00e1-los em contextos pr\u00e1ticos, como simula\u00e7\u00f5es e solu\u00e7\u00f5es para problemas do mundo real.  Agente baseado em conhecimento <p>Os agentes baseados em conhecimento desempenham um papel essencial na intelig\u00eancia artificial (IA), utilizando uma base de conhecimento (Knowledge Base \u2013 KB) para tomar decis\u00f5es racionais e fundamentadas. Eles s\u00e3o projetados para raciocinar sobre informa\u00e7\u00f5es armazenadas e inferir novas conclus\u00f5es, adaptando-se a diferentes cen\u00e1rios.</p> <p>Os agentes baseados em conhecimento desempenham um papel essencial na intelig\u00eancia artificial (IA), utilizando uma base de conhecimento (Knowledge Base \u2013 KB) para tomar decis\u00f5es racionais e fundamentadas. Eles s\u00e3o projetados para raciocinar sobre informa\u00e7\u00f5es armazenadas e inferir novas conclus\u00f5es, adaptando-se a diferentes cen\u00e1rios. De acordo com Poole e Mackworth (2017), o uso de agentes baseados em conhecimento requer uma representa\u00e7\u00e3o formal do conhecimento, que pode ser manipulada e consultada para gerar decis\u00f5es.</p> Principais Conceitos de Agentes Baseados em Conhecimento <ul> <li>Base de Conhecimento (KB): <ul> <li>Conjunto de senten\u00e7as que representam fatos, axiomas e regras sobre o ambiente, conforme destacado por Russell e Norvig (2021).</li> <li>Senten\u00e7as expressas em linguagens formais, como l\u00f3gica proposicional ou l\u00f3gica de predicados, como abordado por Poole e Mackworth (2017).</li> </ul> </li> <li>Opera\u00e7\u00f5es Principais: <ul> <li>TELL: Adiciona novas senten\u00e7as \u00e0 KB.</li> <li>ASK: Consulta ou infere informa\u00e7\u00f5es na KB.</li> </ul> </li> <li>Abordagens de Constru\u00e7\u00e3o: <ul> <li>Declarativa: Inicia com uma KB vazia, sendo enriquecida progressivamente com senten\u00e7as declarativas, como sugerido por Soares (2024).</li> <li>Procedural: Codifica diretamente os comportamentos desejados como instru\u00e7\u00f5es de programa.</li> </ul> </li> </ul> Aplica\u00e7\u00f5es e Exemplos Micromundo: Wumpus World <p>Um dos exemplos mais conhecidos de aplica\u00e7\u00e3o de agentes baseados em conhecimento \u00e9 o Wumpus World, um modelo utilizado para exemplificar como os agentes interagem com o ambiente e tomam decis\u00f5es com base nas informa\u00e7\u00f5es que percebem. Nesse ambiente simulado:</p> <ul> <li>O objetivo do agente \u00e9 encontrar um tesouro, evitando cair em po\u00e7os ou ser devorado pelo monstro Wumpus.</li> <li>Informa\u00e7\u00f5es percept\u00edveis pelo agente incluem:         <ul> <li>Fedor: Indica proximidade do Wumpus, uma informa\u00e7\u00e3o que pode ser armazenada na KB e consultada pelo agente ao tomar decis\u00f5es, conforme discutido por Russell e Norvig (2021).</li> <li>Brisa: Sinaliza a presen\u00e7a de um po\u00e7o pr\u00f3ximo.</li> <li>Brilho: Aponta a localiza\u00e7\u00e3o do tesouro.</li> </ul> </li> <li>Atividades como \"mover-se\", \"virar\" e \"pegar\" o tesouro s\u00e3o realizadas com base nas infer\u00eancias do agente.</li> </ul> Sistemas de Diagn\u00f3stico M\u00e9dico <ul> <li>Agentes baseados em conhecimento podem identificar doen\u00e7as a partir de sintomas, uma aplica\u00e7\u00e3o pr\u00e1tica descrita por Poole e Mackworth (2017).</li> <li>Exemplo: \"Se febre alta e dor de cabe\u00e7a, pode ser meningite\".</li> <li>O mecanismo de infer\u00eancia permite gerar diagn\u00f3sticos precisos e recomenda\u00e7\u00f5es m\u00e9dicas.</li> </ul> Classifica\u00e7\u00e3o de Qualidade do Ar <ul> <li>Agentes utilizam regras declarativas para avaliar n\u00edveis de poluentes, como apresentado por Russell e Norvig (2021).</li> <li>Com base nos dados de polui\u00e7\u00e3o (como PM2.5), classificam a qualidade do ar em categorias como \"Boa\" ou \"Perigosa\".</li> </ul> Vantagens dos Agentes L\u00f3gicos <ul> <li>Flexibilidade: Adapta\u00e7\u00e3o a diferentes ambientes e cen\u00e1rios, permitindo que o agente tome decis\u00f5es baseadas em dados vari\u00e1veis, como apontado por Poole e Mackworth (2017).</li> <li>Explicabilidade: Capacidade de justificar decis\u00f5es com base na KB.</li> <li>Infer\u00eancia Din\u00e2mica: Possibilidade de gerar novas informa\u00e7\u00f5es em tempo real.</li> </ul> Desafios na Implementa\u00e7\u00e3o <ul> <li>Complexidade Computacional: A infer\u00eancia pode ser computacionalmente intensiva em KBs grandes, como discutido por Russell e Norvig (2021).</li> <li>Manuten\u00e7\u00e3o da Consist\u00eancia: Garantir que a base de conhecimento esteja livre de contradi\u00e7\u00f5es.</li> <li>Ambientes Parcialmente Observ\u00e1veis: Nem sempre todas as informa\u00e7\u00f5es do ambiente est\u00e3o dispon\u00edveis, uma limita\u00e7\u00e3o destacada por Poole e Mackworth (2017).</li> </ul>"},{"location":"modulo4/inferencia/","title":"Processo de infer\u00eancia","text":"Processo de infer\u00eancia em Agentes Baseados em Conhecimento <p>     O processo de infer\u00eancia \u00e9 um dos pilares fundamentais em agentes baseados em conhecimento, permitindo-lhes derivar conclus\u00f5es e tomar decis\u00f5es a partir de informa\u00e7\u00f5es conhecidas e regras l\u00f3gicas previamente definidas. Por meio da infer\u00eancia, um agente l\u00f3gico pode explorar o ambiente e raciocinar sobre estados desconhecidos, mesmo quando opera em condi\u00e7\u00f5es de incerteza ou observabilidade parcial. Esse processo \u00e9 essencial para a aplica\u00e7\u00e3o pr\u00e1tica de bases de conhecimento, pois transforma informa\u00e7\u00f5es est\u00e1ticas em a\u00e7\u00f5es inteligentes e din\u00e2micas. </p> <p>     Infer\u00eancia \u00e9 o ato de derivar novas senten\u00e7as ou proposi\u00e7\u00f5es a partir de outras, utilizando um conjunto de regras l\u00f3gicas. Por exemplo, no mundo do Wumpus, se um agente sabe que uma c\u00e9lula \u00e9 adjacente a outra que cont\u00e9m uma brisa, ele pode inferir que a c\u00e9lula vizinha cont\u00e9m um po\u00e7o. Essa conclus\u00e3o \u00e9 baseada na regra l\u00f3gica Breeze_x,y \u21d2 Pit_adjacent(x,y). O processo de infer\u00eancia garante que tais conclus\u00f5es sejam consistentes com as senten\u00e7as existentes na base de conhecimento (RUSSELL; NORVIG, 2021). </p> Tipos de Infer\u00eancia <p>     A infer\u00eancia l\u00f3gica em agentes pode ser realizada de diversas maneiras, utilizando m\u00e9todos como forward chaining (encadeamento para frente) e backward chaining (encadeamento para tr\u00e1s). No forward chaining, o agente aplica regras de infer\u00eancia a partir de fatos conhecidos para deduzir novas informa\u00e7\u00f5es. Por exemplo, se o agente percebe uma brisa em (2,2), ele pode inferir que existe um po\u00e7o em uma das c\u00e9lulas adjacentes. Esse m\u00e9todo \u00e9 \u00fatil em situa\u00e7\u00f5es onde o objetivo \u00e9 descobrir todas as implica\u00e7\u00f5es poss\u00edveis de um conjunto de fatos. </p> <p>     Por outro lado, o backward chaining funciona de forma inversa, come\u00e7ando pelo objetivo e verificando se os fatos existentes na base de conhecimento o sustentam. Por exemplo, se o objetivo do agente \u00e9 determinar se a c\u00e9lula (3,3) \u00e9 segura, ele verifica todas as senten\u00e7as e condi\u00e7\u00f5es que podem provar a aus\u00eancia de po\u00e7os ou Wumpus nessa c\u00e9lula. Essa abordagem \u00e9 mais eficiente quando o objetivo \u00e9 espec\u00edfico, pois foca apenas nas senten\u00e7as necess\u00e1rias para atingi-lo (POOLE; MACKWORTH, 2017). </p> Desafios e Aplica\u00e7\u00f5es Pr\u00e1ticas <p>     Embora o processo de infer\u00eancia seja poderoso, ele tamb\u00e9m enfrenta desafios pr\u00e1ticos, como a complexidade computacional e a escalabilidade. \u00c0 medida que o n\u00famero de senten\u00e7as na base de conhecimento aumenta, o n\u00famero de combina\u00e7\u00f5es poss\u00edveis para infer\u00eancia cresce exponencialmente. Por isso, t\u00e9cnicas adicionais, como o uso de heur\u00edsticas e a combina\u00e7\u00e3o com aprendizado de m\u00e1quina, s\u00e3o frequentemente incorporadas para melhorar a efici\u00eancia e a aplicabilidade dos agentes (RUSSELL; NORVIG, 2021). </p> <p>     Em resumo, o processo de infer\u00eancia permite que agentes baseados em conhecimento combinem informa\u00e7\u00f5es percept\u00edveis com regras l\u00f3gicas para tomar decis\u00f5es inteligentes. Ele \u00e9 a ponte entre o conhecimento est\u00e1tico armazenado e as a\u00e7\u00f5es din\u00e2micas realizadas pelo agente, destacando-se como um dos aspectos mais fundamentais na intelig\u00eancia artificial l\u00f3gica. </p> Exemplo Pr\u00e1tico <p> A seguir, apresento um exemplo pr\u00e1tico de um algoritmo em Python para simula\u00e7\u00e3o de aprendizado para ciclistas. Esse algoritmo utiliza o processo de infer\u00eancia em agentes baseados em conhecimento para treinar ciclistas a tomar decis\u00f5es inteligentes em diferentes cen\u00e1rios, como desviar de buracos, frear em situa\u00e7\u00f5es de risco ou adaptar-se a mudan\u00e7as no terreno.   <pre><code># Base de conhecimento\nrules = {\n    \"buraco \u00e0 frente\": \"desviar para o lado seguro\",\n    \"crian\u00e7a correndo\": \"reduzir velocidade\",\n    \"descida \u00edngreme\": \"reduzir velocidade e frear gradualmente\",\n    \"subida \u00edngreme\": \"pedalar mais forte\",\n    \"chuva forte\": \"reduzir velocidade e aumentar cautela\",\n    \"vento lateral\": \"ajustar equil\u00edbrio\",\n}\n\n# Simula\u00e7\u00e3o de percep\u00e7\u00f5es\nscenarios = [\n    {\"percepcao\": \"buraco \u00e0 frente\", \"descricao\": \"Um buraco aparece na pista.\"},\n    {\"percepcao\": \"crian\u00e7a correndo\", \"descricao\": \"Uma crian\u00e7a atravessa correndo.\"},\n    {\"percepcao\": \"descida \u00edngreme\", \"descricao\": \"H\u00e1 uma descida \u00edngreme \u00e0 frente.\"},\n    {\"percepcao\": \"subida \u00edngreme\", \"descricao\": \"A pista sobe abruptamente.\"},\n    {\"percepcao\": \"chuva forte\", \"descricao\": \"Est\u00e1 chovendo intensamente.\"},\n    {\"percepcao\": \"vento lateral\", \"descricao\": \"O vento est\u00e1 forte na lateral.\"},\n]\n\ndef infer_action(percepcao):\n    \"\"\"\n    Realiza infer\u00eancia l\u00f3gica com base na percep\u00e7\u00e3o.\n    \"\"\"\n    if percepcao in rules:\n        return rules[percepcao]\n    else:\n        return \"Nenhuma a\u00e7\u00e3o definida para esta percep\u00e7\u00e3o.\"\n\ndef simulate_training(scenarios):\n    \"\"\"\n    Simula o treinamento do ciclista com base nos cen\u00e1rios.\n    \"\"\"\n    print(\"Iniciando simula\u00e7\u00e3o de treinamento...\\n\")\n    for scenario in scenarios:\n        print(f\"--- Cen\u00e1rio: {scenario['descricao']} ---\")\n        percepcao = scenario[\"percepcao\"]\n        acao = infer_action(percepcao)\n        print(f\"Percep\u00e7\u00e3o: {percepcao}\")\n        print(f\"A\u00e7\u00e3o sugerida: {acao}\\n\")\n\n# Executa a simula\u00e7\u00e3o\nsimulate_training(scenarios)\n\n</code></pre> Explica\u00e7\u00e3o do Algoritmo <p>1. Base de Conhecimento (rules): Cont\u00e9m regras l\u00f3gicas que descrevem como o ciclista deve reagir \u00e0s percep\u00e7\u00f5es (por exemplo, um buraco no caminho ou uma descida \u00edngreme).  <p>2. Percep\u00e7\u00e3o do Ambiente (scenarios): Incluem informa\u00e7\u00f5es sobre obst\u00e1culos, terreno e condi\u00e7\u00f5es externas (como vento ou chuva).  <p>3. Infer\u00eancia l\u00f3gica (infer_action): O agente utiliza encadeamento para frente (forward chaining) para aplicar regras e tomar decis\u00f5es com base nas percep\u00e7\u00f5es.  <p>4. A\u00e7\u00e3o:O m\u00e9todo act integra os passos de percep\u00e7\u00e3o, decis\u00e3o e execu\u00e7\u00e3o da a\u00e7\u00e3o, exibindo o fluxo completo para cada percep\u00e7\u00e3o.  <p>4. Simula\u00e7\u00e3o de Cen\u00e1rios (simulate_training): Diversos cen\u00e1rios s\u00e3o simulados, e o agente toma decis\u00f5es em cada um deles.  Sa\u00edda do Algoritmo <pre><code>Iniciando simula\u00e7\u00e3o de treinamento...\n\n--- Cen\u00e1rio: Um buraco aparece na pista. ---\nPercep\u00e7\u00e3o: buraco \u00e0 frente\nA\u00e7\u00e3o sugerida: desviar para o lado seguro\n\n--- Cen\u00e1rio: Uma crian\u00e7a atravessa correndo. ---\nPercep\u00e7\u00e3o: crian\u00e7a correndo\nA\u00e7\u00e3o sugerida: reduzir velocidade\n\n--- Cen\u00e1rio: H\u00e1 uma descida \u00edngreme \u00e0 frente. ---\nPercep\u00e7\u00e3o: descida \u00edngreme\nA\u00e7\u00e3o sugerida: reduzir velocidade e frear gradualmente\n\n--- Cen\u00e1rio: A pista sobe abruptamente. ---\nPercep\u00e7\u00e3o: subida \u00edngreme\nA\u00e7\u00e3o sugerida: pedalar mais forte\n\n--- Cen\u00e1rio: Est\u00e1 chovendo intensamente. ---\nPercep\u00e7\u00e3o: chuva forte\nA\u00e7\u00e3o sugerida: reduzir velocidade e aumentar cautela\n\n--- Cen\u00e1rio: O vento est\u00e1 forte na lateral. ---\nPercep\u00e7\u00e3o: vento lateral\nA\u00e7\u00e3o sugerida: ajustar equil\u00edbrio\n</code></pre> Vantagens do Algoritmo <ol> <li>Flexibilidade: F\u00e1cil de adicionar novas regras ou cen\u00e1rios.</li> <li>Explicabilidade: O processo de infer\u00eancia \u00e9 transparente e compreens\u00edvel.</li> <li>Aplicabilidade: Pode ser adaptado para treinar ciclistas em simuladores de realidade virtual ou sistemas reais.</li> </ol> Extens\u00f5es Poss\u00edveis <ul> <li>Incorporar aprendizado de m\u00e1quina para ajustar as regras com base no desempenho.</li> <li>Usar sensores reais para captar percep\u00e7\u00f5es do ambiente em tempo real.</li> <li>Expandir para m\u00faltiplos agentes (ex.: intera\u00e7\u00e3o entre ciclistas e ve\u00edculos).</li> </ul> <p>Esse algoritmo ilustra como o processo de infer\u00eancia em agentes baseados em conhecimento pode ser aplicado para criar treinamentos simulados de forma eficiente e pr\u00e1tica.</p>"},{"location":"modulo4/logica-propo/","title":"Agente baseado em l\u00f3gica proposicional","text":"Agente baseado em l\u00f3gica proposicional <p>     O agente baseado em l\u00f3gica proposicional utiliza proposi\u00e7\u00f5es l\u00f3gicas para inferir conhecimento sobre o ambiente e tomar decis\u00f5es. Ele opera em micromundos bem definidos, como o Wumpus World, onde as regras e estados s\u00e3o claramente estabelecidos. Segundo Soares (2024), a l\u00f3gica proposicional oferece ferramentas como a validade, a satisfatibilidade e as regras de infer\u00eancia, que permitem derivar conclus\u00f5es corretas e completas. </p> Processo de Infer\u00eancia <p>     A infer\u00eancia \u00e9 o n\u00facleo da l\u00f3gica proposicional, permitindo deduzir novas informa\u00e7\u00f5es a partir de fatos e regras conhecidas. Por exemplo, no Wumpus World, o agente pode deduzir que uma c\u00e9lula \u00e9 segura se todas as c\u00e9lulas adjacentes conhecidas n\u00e3o apresentam perigo, utilizando uma l\u00f3gica como \u00acPit_x,y \u2227 \u00acWumpus_x,y. </p> <p>     T\u00e9cnicas como Modus Ponens e resolu\u00e7\u00e3o s\u00e3o amplamente empregadas. Modus Ponens segue a estrutura \"Se P \u21d2 Q e P forem verdadeiros, ent\u00e3o Q \u00e9 verdadeiro\". A resolu\u00e7\u00e3o, por outro lado, combina cl\u00e1usulas complementares para deduzir novas informa\u00e7\u00f5es. Essas abordagens garantem que o agente tome decis\u00f5es com base em um modelo confi\u00e1vel e l\u00f3gico. </p> Vantagens e Limita\u00e7\u00f5es <p> Efici\u00eancia em Ambientes Controlados: Agentes l\u00f3gicos s\u00e3o ideais para resolver problemas em micromundos bem definidos, como jogos e simula\u00e7\u00f5es. O Wumpus World \u00e9 um exemplo cl\u00e1ssico usado para ilustrar a infer\u00eancia em IA (RUSSELL; NORVIG, 2021). </p> <p> Limita\u00e7\u00f5es Pr\u00e1ticas: A l\u00f3gica proposicional carece de expressividade para lidar com incertezas ou rela\u00e7\u00f5es complexas. Em ambientes reais, isso pode limitar a aplica\u00e7\u00e3o pr\u00e1tica, como observado por Levesque e Lakemeyer (2001). </p> Impacto na Intelig\u00eancia Artificial Moderna <p>     Apesar de suas limita\u00e7\u00f5es, agentes baseados em l\u00f3gica proposicional estabeleceram fundamentos importantes para a IA, como o racioc\u00ednio simb\u00f3lico e o planejamento. Esses conceitos s\u00e3o usados em sistemas de verifica\u00e7\u00e3o formal e automa\u00e7\u00e3o de provas matem\u00e1ticas. </p> <p>     Um exemplo de aplica\u00e7\u00e3o pr\u00e1tica \u00e9 a automa\u00e7\u00e3o de diagn\u00f3sticos m\u00e9dicos. Por exemplo, regras como \"Se febre \u2227 tosse \u21d2 gripe\" podem ser usadas em sistemas especialistas para sugerir diagn\u00f3sticos baseados em sintomas. </p> Exemplo Pr\u00e1tico <p>Aqui est\u00e1 um exemplo pr\u00e1tico de um agente baseado em l\u00f3gica proposicional que simula a tomada de decis\u00e3o de um ciclista ao pedalar por um caminho cheio de poss\u00edveis obst\u00e1culos. O agente \u00e9 projetado para perceber o ambiente, identificar o tipo de obst\u00e1culo (como crian\u00e7as atravessando, lixo na pista ou buracos no ch\u00e3o) e tomar a a\u00e7\u00e3o apropriada com base em regras predefinidas. Essas regras representam a base de conhecimento do agente, permitindo que ele associe percep\u00e7\u00f5es a a\u00e7\u00f5es espec\u00edficas e reaja de forma l\u00f3gica e eficiente.   <pre><code>class BicycleAgent:\n    def __init__(self):\n        # Base de conhecimento (regras de l\u00f3gica proposicional)\n        self.knowledge_base = {\n            \"obstacle_child\": \"stop\",\n            \"obstacle_trash\": \"swerve_right\",\n            \"obstacle_hole\": \"swerve_left\",\n            \"no_obstacle\": \"move_forward\"\n        }\n\n    def perceive_environment(self, perception):\n        \"\"\"\n        Simula a percep\u00e7\u00e3o do ambiente e retorna a proposi\u00e7\u00e3o correspondente.\n        \"\"\"\n        if perception == \"child\":\n            return \"obstacle_child\"\n        elif perception == \"trash\":\n            return \"obstacle_trash\"\n        elif perception == \"hole\":\n            return \"obstacle_hole\"\n        else:\n            return \"no_obstacle\"\n\n    def decide_action(self, proposition):\n        \"\"\"\n        Toma uma decis\u00e3o com base na base de conhecimento e na proposi\u00e7\u00e3o percebida.\n        \"\"\"\n        return self.knowledge_base.get(proposition, \"wait\")\n\n    def act(self, perception):\n        \"\"\"\n        Fluxo completo: percep\u00e7\u00e3o -&gt; decis\u00e3o -&gt; a\u00e7\u00e3o.\n        \"\"\"\n        proposition = self.perceive_environment(perception)\n        action = self.decide_action(proposition)\n        print(f\"Perception: {perception}\")\n        print(f\"Proposition: {proposition}\")\n        print(f\"Action: {action}\\n\")\n\n\n# Simula\u00e7\u00e3o do ambiente\ndef simulate_bicycle_agent():\n    agent = BicycleAgent()\n\n    # Lista de percep\u00e7\u00f5es simulando obst\u00e1culos no caminho\n    perceptions = [\"child\", \"trash\", \"hole\", \"no_obstacle\", \"trash\", \"child\"]\n\n    for perception in perceptions:\n        agent.act(perception)\n\n\nif __name__ == \"__main__\":\n    simulate_bicycle_agent()\n</code></pre> Explica\u00e7\u00e3o do Algoritmo <p>1. Base de Conhecimento: \u00c9 definida como um dicion\u00e1rio onde cada proposi\u00e7\u00e3o \u00e9 mapeada para uma a\u00e7\u00e3o espec\u00edfica.  <p>2. Percep\u00e7\u00e3o: O m\u00e9todo perceive_environment traduz as percep\u00e7\u00f5es (crian\u00e7as, lixo, buracos, etc.) em proposi\u00e7\u00f5es.  <p>3. Decis\u00e3o: O m\u00e9todo decide_action utiliza a base de conhecimento para determinar a a\u00e7\u00e3o apropriada com base na proposi\u00e7\u00e3o recebida.  <p>4. A\u00e7\u00e3o:O m\u00e9todo act integra os passos de percep\u00e7\u00e3o, decis\u00e3o e execu\u00e7\u00e3o da a\u00e7\u00e3o, exibindo o fluxo completo para cada percep\u00e7\u00e3o.  <p>4. Simula\u00e7\u00e3o:A fun\u00e7\u00e3o simulate_bicycle_agent cria uma inst\u00e2ncia do agente e processa uma sequ\u00eancia de percep\u00e7\u00f5es, representando diferentes obst\u00e1culos encontrados no caminho.  Sa\u00edda do Algoritmo <pre><code>Perception: child\nProposition: obstacle_child\nAction: stop\n\nPerception: trash\nProposition: obstacle_trash\nAction: swerve_right\n\nPerception: hole\nProposition: obstacle_hole\nAction: swerve_left\n\nPerception: no_obstacle\nProposition: no_obstacle\nAction: move_forward\n\nPerception: trash\nProposition: obstacle_trash\nAction: swerve_right\n\nPerception: child\nProposition: obstacle_child\nAction: stop\n</code></pre> <p>Esse exemplo mostra como o agente decide a\u00e7\u00f5es baseadas em percep\u00e7\u00f5es do ambiente utilizando l\u00f3gica proposicional.</p> Conclus\u00e3o <p>     Agentes baseados em l\u00f3gica proposicional s\u00e3o ferramentas poderosas em ambientes controlados, mas possuem limita\u00e7\u00f5es pr\u00e1ticas em cen\u00e1rios complexos. No entanto, eles continuam sendo uma base te\u00f3rica essencial para avan\u00e7os em intelig\u00eancia artificial. </p>"},{"location":"modulo4/logica/","title":"L\u00f3gica","text":"L\u00f3gica em Agentes Baseados em Conhecimento <p>     A l\u00f3gica \u00e9 um dos pilares fundamentais da Intelig\u00eancia Artificial (IA), sendo utilizada para representar conhecimento, raciocinar e tomar decis\u00f5es. Por meio de regras formais e processos inferenciais, ela permite que agentes inteligentes operem de maneira eficiente e racional. Neste contexto, os conceitos de sintaxe, sem\u00e2ntica e infer\u00eancia desempenham pap\u00e9is cruciais. </p> Conceitos Fundamentais <p>     A sintaxe define como construir senten\u00e7as logicamente v\u00e1lidas em uma linguagem formal. Por exemplo, uma senten\u00e7a como \"(P \u2227 Q) \u21d2 R\" \u00e9 bem constru\u00edda, enquanto \"P \u2227 \u21d2 Q\" n\u00e3o \u00e9. J\u00e1 a sem\u00e2ntica refere-se ao significado dessas senten\u00e7as, determinando sua veracidade em modelos espec\u00edficos. Por exemplo, na equa\u00e7\u00e3o \"x + y = 4\", um modelo onde x = 2 e y = 2 satisfaz a senten\u00e7a, tornando-a verdadeira. Por fim, a infer\u00eancia \u00e9 o processo de derivar novas senten\u00e7as a partir de senten\u00e7as j\u00e1 conhecidas. Um exemplo cl\u00e1ssico \u00e9: se \"P \u21d2 Q\" e \"P\" s\u00e3o verdadeiros, podemos inferir que \"Q\" tamb\u00e9m \u00e9 verdadeiro. </p> Tipos de L\u00f3gica <p>     A l\u00f3gica proposicional trabalha com proposi\u00e7\u00f5es que podem ser verdadeiras ou falsas. Ela utiliza operadores como: </p> S\u00edmbolo Significado Explica\u00e7\u00e3o \u00ac NOT (Nega\u00e7\u00e3o) \u00acP \u00e9 verdadeiro se P for falso. \u2227 AND (Conjun\u00e7\u00e3o) P \u2227 Q \u00e9 verdadeiro apenas se ambos forem verdadeiros. \u2228 OR (Disjun\u00e7\u00e3o) P \u2228 Q \u00e9 verdadeiro se pelo menos um dos dois for verdadeiro. \u21d2 IMPLICA\u00c7\u00c3O P \u21d2 Q \u00e9 falso somente se P for verdadeiro e Q for falso. \u21d4 BICONDICIONAL P \u21d4 Q \u00e9 verdadeiro quando ambos t\u00eam o mesmo valor l\u00f3gico. <p>     Al\u00e9m disso, a l\u00f3gica \u00e9 amplamente empregada em agentes baseados em conhecimento, que utilizam senten\u00e7as l\u00f3gicas para descrever o estado do mundo e realizar infer\u00eancias. Um exemplo \u00e9 a aplica\u00e7\u00e3o da regra de Modus Ponens: se um agente sabe que \"Breeze_2,2 \u21d2 Pit_1,2 \u2228 Pit_2,3\" e \"Breeze_2,2\" \u00e9 verdadeiro, ele pode inferir que \"Pit_1,2 \u2228 Pit_2,3\" tamb\u00e9m \u00e9 verdadeiro. </p> Conclus\u00e3o <p>     A l\u00f3gica \u00e9 essencial para a cria\u00e7\u00e3o de agentes inteligentes, pois fornece uma base s\u00f3lida para o racioc\u00ednio formal e a tomada de decis\u00f5es. Apesar dos desafios relacionados \u00e0 complexidade computacional, sua integra\u00e7\u00e3o com t\u00e9cnicas modernas, como aprendizado de m\u00e1quina, continua a expandir suas aplica\u00e7\u00f5es e import\u00e2ncia no campo da IA. </p>"},{"location":"modulo4/referencias/","title":"Refer\u00eancias","text":"Refer\u00eancias <p>POOLE, David L.; MACKWORTH, Alan K. Artificial Intelligence: Foundations of Computational Agent. 2. ed. Cambridge: Cambridge University Press, 2017.</p> <p>RUSSELL, Stuart; NORVIG, Peter. Intelig\u00eancia Artificial: Uma Abordagem Moderna. 4. ed. Londres: Pearson, 2021.</p> <p>SOARES, Fabiano. FGA0221 - Intelig\u00eancia Artificial - 2024/2. Gama-DF: Universidade de Bras\u00edlia, 2024.</p> <p>LEVESQUE, H. J.; LAKEMEYER, G. The Logic of Knowledge Bases. 2001</p>"}]}